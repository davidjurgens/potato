<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{annotation_task_name}}</title>

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

    <!-- Custom Styles -->
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">

    <!-- jQuery (required for span annotation) -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
</head>

<body>
    <!-- Header navigation bar -->
    <nav class="navbar sticky-top shadow-sm" style="background-color: var(--primary-color); padding: 0.75rem 1rem; margin-bottom: 1.5rem;">
        <div class="container-fluid d-flex align-items-center">
            <!-- Task name (left aligned) -->
            <div class="navbar-brand">
                <span class="fw-bold" style="color: var(--light-color); font-size: 1.25rem">{{annotation_task_name}}</span>
            </div>

            <!-- Middle section with progress and navigation -->
            <div class="d-flex align-items-center justify-content-center flex-grow-1 gap-4">
                <!-- Progress counter -->
                <div class="d-flex align-items-center" style="color: var(--light-color); margin-right: 40px">
                    <span>Progress: <span class="fw-medium" id="progress-counter">0/0</span></span>
                </div>

                <!-- Jump to item form -->
                <div style="margin-left: 40px">
                    <div class="d-flex align-items-center">
                        <label for="go_to" class="me-2" style="color: var(--light-color); margin-bottom: 0">Go to:</label>
                        <input type="number" id="go_to" class="form-control form-control-sm me-2"
                               style="width: 70px; height: 31px; border: none; border-radius: var(--radius);"
                               value="" min="0" required>
                        <button type="button" class="shadcn-button" id="go-to-btn"
                                style="height: 31px; line-height: 1; padding: 0 0.75rem; background-color: var(--light-color); color: var(--primary-color); border: none;">
                            Go
                        </button>
                    </div>
                </div>
            </div>

            <!-- User info and logout (right aligned) -->
            <div class="d-flex align-items-center"
                 style="background-color: rgba(255, 255, 255, 0.15); padding: 0.5rem 1rem; border-radius: var(--radius);">
                <div class="me-3" style="color: var(--light-color)">
                    <span>Logged in as <span class="fw-medium" id="username-display">{{username}}</span></span>
                </div>
                <div class="border-start" style="padding-left: 20px; height: 24px; display: flex; align-items: center;">
                    <a href="/logout" class="shadcn-button"
                       style="background-color: var(--light-color); color: var(--primary-color); height: auto; padding: 0.25rem 0.75rem !important; font-size: 0.875rem; min-width: 60px; text-align: center; border: none; text-decoration: none;">
                        Logout
                    </a>
                </div>
            </div>
        </div>
    </nav>

    <div class="container-fluid">
        <!-- Main annotation area -->
        <div id="task_layout" class="shadcn-card mb-4">
            <div class="shadcn-card-content">
                <!-- Loading state -->
                <div id="loading-state" class="text-center py-5">
                    <div class="loading-spinner mb-3"></div>
                    <p>Loading annotation interface...</p>
                </div>

                <!-- Error state -->
                <div id="error-state" class="error-message" style="display: none;">
                    <h5><i class="fas fa-exclamation-triangle me-2"></i>Error</h5>
                    <p id="error-message-text"></p>
                    <button class="shadcn-button shadcn-button-primary" onclick="loadCurrentInstance()">
                        <i class="fas fa-redo me-2"></i>Retry
                    </button>
                </div>

                <!-- Main content area -->
                <div id="main-content" style="display: none;">
                    <!-- Instance text -->
                    <div class="mb-4">
                        <h5 class="mb-3">Text to Annotate:</h5>
                        <div id="instance-text" class="p-3 border rounded" style="background-color: var(--light-bg); min-height: 100px;">
                            <!-- Instance text will be loaded here -->
                        </div>
                    </div>
                    <!-- Hidden input for instance_id -->
                    <input type="hidden" id="instance_id" name="instance_id" value="">

                    <!-- Annotation forms -->
                    <div id="annotation-forms">
                        {{ TASK_LAYOUT }}
                    </div>
                </div>
            </div>
        </div>

        <!-- Navigation buttons -->
        <div class="my-4">
            <div class="d-flex justify-content-between align-items-center">
                <!-- Previous button -->
                <div>
                    <button class="shadcn-button shadcn-button-outline me-2" id="prev-btn" onclick="navigateToPrevious()">
                        <i class="fas fa-arrow-left me-2"></i>Previous
                    </button>
                </div>

                <!-- Next button -->
                <div>
                    <button class="shadcn-button shadcn-button-primary" id="next-btn" onclick="navigateToNext()">
                        Next<i class="fas fa-arrow-right ms-2"></i>
                    </button>
                </div>
            </div>
        </div>

        <!-- Footer -->
        <hr style="color: var(--border)">
        <footer class="py-2 text-center" style="font-size: 0.75rem; color: var(--muted-foreground)">
            Copyright &copy; 2025
            <a href="https://blablablab.si.umich.edu/" style="color: var(--primary); text-decoration: none">Blablablab</a>
            <span class="mx-2">|</span>
            <a href="https://github.com/davidjurgens/potato" style="color: var(--primary); text-decoration: none">Chat with us on GitHub</a>
            <span class="mx-2">|</span>
            <a href="https://github.com/davidjurgens/potato#cite-us" style="color: var(--primary); text-decoration: none">Cite Us</a>
        </footer>
    </div>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>

    <!-- Configuration from server -->
    <script type="text/javascript">
        window.config = {
            annotation_task_name: "{{ annotation_task_name }}",
            debug: {{ debug | tojson }},
            api_key: "test_api_key"
        };
    </script>

    <script>
        // Global state
        let currentInstance = null;
        let currentAnnotations = {};
        let userState = null;
        let isLoading = false;
        let textSaveTimer = null;
        let currentSpanAnnotations = [];

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            loadCurrentInstance();
            setupEventListeners();
        });

        function setupEventListeners() {
            // Go to button
            document.getElementById('go-to-btn').addEventListener('click', function() {
                const goToValue = document.getElementById('go_to').value;
                if (goToValue && goToValue > 0) {
                    navigateToInstance(parseInt(goToValue));
                }
            });

            // Enter key on go to input
            document.getElementById('go_to').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    document.getElementById('go-to-btn').click();
                }
            });

            // Keyboard navigation
            document.addEventListener('keydown', function(e) {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                    return; // Don't handle navigation when typing
                }

                switch(e.key) {
                    case 'ArrowLeft':
                        e.preventDefault();
                        navigateToPrevious();
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        navigateToNext();
                        break;
                }
            });
        }

        async function loadCurrentInstance() {
            try {
                setLoading(true);
                showError(false);

                // Get current user state
                const headers = {};
                if (window.config.api_key) {
                    headers['X-API-Key'] = window.config.api_key;
                }
                const response = await fetch('/admin/user_state/{{username}}', {
                    headers: {
                        ...headers,
                        'X-API-Key': 'admin_api_key'
                    }
                });
                if (!response.ok) {
                    throw new Error('Failed to load user state');
                }

                userState = await response.json();
                console.log('[DEBUG] loadCurrentInstance: userState =', userState);

                if (!userState.current_instance) {
                    showError(true, 'No instances available for annotation');
                    return;
                }

                currentInstance = userState.current_instance;
                updateProgressDisplay();
                updateInstanceDisplay();
                restoreSpanAnnotationsFromHTML();
                loadAnnotations();
                generateAnnotationForms();

                // Populate input values with existing annotations AFTER forms are generated
                setTimeout(() => {
                    populateInputValues();
                }, 0);

            } catch (error) {
                console.error('Error loading current instance:', error);
                showError(true, error.message);
            } finally {
                setLoading(false);
            }
        }

        function updateProgressDisplay() {
            const progress = userState.assignments;
            const progressText = `${progress.annotated}/${progress.total}`;
            document.getElementById('progress-counter').textContent = progressText;
        }

        function updateInstanceDisplay() {
            const instanceText = document.getElementById('instance-text');
            if (currentInstance && currentInstance.displayed_text) {
                console.log('[DEBUG] updateInstanceDisplay: setting #instance-text.innerHTML to:', currentInstance.displayed_text);
                instanceText.innerHTML = currentInstance.displayed_text;
            } else {
                console.log('[DEBUG] updateInstanceDisplay: setting #instance-text.textContent to: No text available');
                instanceText.textContent = 'No text available';
            }
            // Update the hidden input for instance_id
            const instanceIdInput = document.getElementById('instance_id');
            if (instanceIdInput && currentInstance && currentInstance.id) {
                instanceIdInput.value = currentInstance.id;
            }
        }

        async function loadAnnotations() {
            try {
                console.log('üîç Loading annotations for instance:', currentInstance.id);
                console.log('üîç User state annotations:', userState.annotations);
                console.log('üîç User state annotations by_instance:', userState.annotations.by_instance);

                const rawAnnotations = userState.annotations.by_instance[currentInstance.id] || {};
                console.log('üîç Raw annotations for current instance:', rawAnnotations);

                // Transform the server format to frontend format
                // Server format: {"schema:label": "value"} (e.g., {"feedback:text_box": "value"})
                // Frontend format: {"schema": {"label": "value"}} (e.g., {"feedback": {"text_box": "value"}})
                currentAnnotations = {};

                for (const [labelKey, value] of Object.entries(rawAnnotations)) {
                    console.log('üîç Processing annotation key:', labelKey, 'value:', value);

                    // Parse the label key format: "schema:label"
                    const parts = labelKey.split(':');
                    if (parts.length === 2) {
                        const schemaName = parts[0];
                        const labelName = parts[1];
                        console.log('üîç Parsed schema:', schemaName, 'label:', labelName);

                        if (!currentAnnotations[schemaName]) {
                            currentAnnotations[schemaName] = {};
                        }
                        currentAnnotations[schemaName][labelName] = value;
                        console.log('üîç Added annotation:', schemaName, labelName, value);
                    } else {
                        // Handle legacy format: "Label(schema:sentiment, name:neutral)"
                        const match = labelKey.match(/Label\(schema:([^,]+), name:([^)]+)\)/);
                        if (match) {
                            const schemaName = match[1];
                            const labelName = match[2];
                            console.log('üîç Parsed legacy format - schema:', schemaName, 'label:', labelName);

                            if (!currentAnnotations[schemaName]) {
                                currentAnnotations[schemaName] = {};
                            }
                            currentAnnotations[schemaName][labelName] = value;
                            console.log('üîç Added legacy annotation:', schemaName, labelName, value);
                        } else {
                            // Handle direct key-value pairs (fallback)
                            console.warn('‚ùå Could not parse annotation key:', labelKey);
                        }
                    }
                }

                console.log('üîç Final currentAnnotations:', currentAnnotations);
            } catch (error) {
                console.error('‚ùå Error loading annotations:', error);
                currentAnnotations = {};
            }
        }

        function generateAnnotationForms() {
            const formsContainer = document.getElementById('annotation-forms');

            // The server generates the forms, so we just need to set up event listeners
            // The forms are already in the HTML from server-side generation
            setupInputEventListeners();
        }











        async function saveAnnotations() {
            if (!currentInstance) return;

            try {
                const headers = {
                    'Content-Type': 'application/json',
                };

                // Add API key if available
                if (window.config.api_key) {
                    headers['X-API-Key'] = window.config.api_key;
                }

                // Save both label and span annotations via /updateinstance
                const spanAnnotations = extractSpanAnnotationsFromDOM();
                console.log('[DEBUG] saveAnnotations: spanAnnotations to send:', spanAnnotations);

                // Transform currentAnnotations to the format expected by /updateinstance
                const labelAnnotations = {};
                for (const [schema, labels] of Object.entries(currentAnnotations)) {
                    for (const [label, value] of Object.entries(labels)) {
                        const key = `${schema}:${label}`;
                        labelAnnotations[key] = value;
                    }
                }

                const response = await fetch('/updateinstance', {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify({
                        instance_id: currentInstance.id,
                        annotations: labelAnnotations,
                        span_annotations: spanAnnotations
                    })
                });

                if (response.ok) {
                    const result = await response.json();
                    console.log('[DEBUG] saveAnnotations: annotations saved:', result);
                } else {
                    console.warn('[DEBUG] saveAnnotations: failed to save annotations:', await response.text());
                }

                return true;

            } catch (error) {
                console.error('Error saving annotations:', error);
                showError(true, 'Failed to save annotations: ' + error.message);
                return false;
            }
        }

        async function navigateToPrevious() {
            if (isLoading) return;

            try {
                setLoading(true);
                const headers = {
                    'Content-Type': 'application/json',
                };
                if (window.config.api_key) {
                    headers['X-API-Key'] = window.config.api_key;
                }
                const response = await fetch('/annotate', {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify({
                        action: 'prev_instance',
                        instance_id: currentInstance?.id
                    })
                });

                if (response.ok) {
                    await loadCurrentInstance();
                } else {
                    throw new Error('Failed to navigate to previous instance');
                }
            } catch (error) {
                console.error('Error navigating to previous:', error);
                showError(true, error.message);
            } finally {
                setLoading(false);
            }
        }

        async function navigateToNext() {
            if (isLoading) return;

            // Save current annotations before navigating
            const saved = await saveAnnotations();
            if (!saved) return;

            try {
                setLoading(true);
                const headers = {
                    'Content-Type': 'application/json',
                };
                if (window.config.api_key) {
                    headers['X-API-Key'] = window.config.api_key;
                }
                const response = await fetch('/annotate', {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify({
                        action: 'next_instance',
                        instance_id: currentInstance?.id
                    })
                });

                if (response.ok) {
                    await loadCurrentInstance();
                } else {
                    throw new Error('Failed to navigate to next instance');
                }
            } catch (error) {
                console.error('Error navigating to next:', error);
                showError(true, error.message);
            } finally {
                setLoading(false);
            }
        }

        async function navigateToInstance(instanceIndex) {
            if (isLoading) return;

            try {
                setLoading(true);
                const headers = {
                    'Content-Type': 'application/json',
                };
                if (window.config.api_key) {
                    headers['X-API-Key'] = window.config.api_key;
                }
                const response = await fetch('/annotate', {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify({
                        action: 'go_to',
                        go_to: instanceIndex
                    })
                });

                if (response.ok) {
                    await loadCurrentInstance();
                } else {
                    throw new Error('Failed to navigate to instance');
                }
            } catch (error) {
                console.error('Error navigating to instance:', error);
                showError(true, error.message);
            } finally {
                setLoading(false);
            }
        }

        function setLoading(loading) {
            isLoading = loading;
            const loadingState = document.getElementById('loading-state');
            const mainContent = document.getElementById('main-content');
            const prevBtn = document.getElementById('prev-btn');
            const nextBtn = document.getElementById('next-btn');

            if (loading) {
                loadingState.style.display = 'block';
                mainContent.style.display = 'none';
                prevBtn.disabled = true;
                nextBtn.disabled = true;
            } else {
                loadingState.style.display = 'none';
                mainContent.style.display = 'block';
                prevBtn.disabled = false;
                nextBtn.disabled = false;
            }
        }

        function showError(show, message = '') {
            const errorState = document.getElementById('error-state');
            const errorMessage = document.getElementById('error-message-text');
            const mainContent = document.getElementById('main-content');

            if (show) {
                errorState.style.display = 'block';
                mainContent.style.display = 'none';
                errorMessage.textContent = message;
            } else {
                errorState.style.display = 'none';
                mainContent.style.display = 'block';
            }
        }

        // Utility functions for annotation handling
        function updateAnnotation(schema, label, value) {
            if (!currentAnnotations[schema]) {
                currentAnnotations[schema] = {};
            }
            currentAnnotations[schema][label] = value;
        }

        // Function to handle "None" option in multiselect annotations
        function whetherNone(checkbox) {
            // This function is used to uncheck all the other labels when "None" is checked
            // and vice versa
            var x = document.getElementsByClassName(checkbox.className);
            var i;
            for (i = 0; i < x.length; i++) {
                if(checkbox.value == "None" && x[i].value != "None") x[i].checked = false;
                if(checkbox.value != "None" && x[i].value == "None") x[i].checked = false;
            }
            // Also trigger the input change handler for the current checkbox
            handleInputChange(checkbox);
        }

        // Input event handling functions
        function setupInputEventListeners() {
            // Set up event listeners for all annotation inputs
            const inputs = document.querySelectorAll('.annotation-input');

            inputs.forEach(input => {
                const inputType = input.type;
                const tagName = input.tagName.toLowerCase();

                if (inputType === 'text' || tagName === 'textarea') {
                    // Text inputs and textareas - debounced saving
                    let timer;
                    input.addEventListener('input', function(event) {
                        clearTimeout(timer);
                        timer = setTimeout(() => {
                            handleInputChange(event.target);
                        }, 1000);
                    });
                    console.log(`Set up event listener for ${tagName} element:`, input.id);
                } else if (inputType === 'radio' || inputType === 'checkbox') {
                    // Radio/checkbox inputs - immediate saving
                    input.addEventListener('change', function(event) {
                        handleInputChange(event.target);
                    });
                } else if (inputType === 'range') {
                    // Slider inputs - immediate saving with value display
                    input.addEventListener('input', function(event) {
                        const valueDisplay = document.getElementById(`${input.name}-value`);
                        if (valueDisplay) {
                            valueDisplay.textContent = event.target.value;
                        }
                        handleInputChange(event.target);
                    });
                } else if (tagName === 'select') {
                    // Select inputs - immediate saving
                    input.addEventListener('change', function(event) {
                        handleInputChange(event.target);
                    });
                } else if (inputType === 'number') {
                    // Number inputs - debounced saving
                    let timer;
                    input.addEventListener('input', function(event) {
                        clearTimeout(timer);
                        timer = setTimeout(() => {
                            handleInputChange(event.target);
                        }, 1000);
                    });
                }
            });
        }

        function handleInputChange(element) {
            const schema = element.getAttribute('schema');
            const labelName = element.getAttribute('label_name');
            const inputType = element.type;
            const tagName = element.tagName.toLowerCase();

            console.log(`handleInputChange called for ${tagName} element:`, element.id, 'schema:', schema, 'label:', labelName);

            if (!schema || !labelName) {
                console.warn('Missing schema or label_name for input:', element);
                return;
            }

            let value;

            if (inputType === 'radio') {
                // For radio buttons, only save if checked
                if (element.checked) {
                    value = element.value;
                } else {
                    return; // Don't save unchecked radio buttons
                }
            } else if (inputType === 'checkbox') {
                // For checkboxes, save the checked state
                if (element.checked) {
                    value = element.value;
                } else {
                    // For unchecked checkboxes, remove the annotation or set to false
                    if (currentAnnotations[schema] && currentAnnotations[schema][labelName]) {
                        delete currentAnnotations[schema][labelName];
                        // If the schema is empty, remove it too
                        if (Object.keys(currentAnnotations[schema]).length === 0) {
                            delete currentAnnotations[schema];
                        }
                    }
                    console.log(`Removed annotation: ${schema}.${labelName}`);

                    // Auto-save the removal
                    clearTimeout(textSaveTimer);
                    textSaveTimer = setTimeout(() => {
                        saveAnnotations();
                    }, 500);
                    return;
                }
            } else {
                // For text inputs, save the value
                value = element.value;
            }

            // Update the current annotations
            updateAnnotation(schema, labelName, value);
            console.log(`Updated annotation: ${schema}.${labelName} = ${value}`);

            // Auto-save
            clearTimeout(textSaveTimer);
            textSaveTimer = setTimeout(() => {
                saveAnnotations();
            }, 500);
        }

        function populateInputValues() {
            if (!currentAnnotations || !userState) return;

            console.log('üîç Populating input values with annotations:', currentAnnotations);

            // Populate text inputs and textareas
            const textInputs = document.querySelectorAll('input[type="text"], textarea.annotation-input');
            console.log('üîç Found text inputs and textareas:', textInputs.length);

            textInputs.forEach(input => {
                const schema = input.getAttribute('schema');
                const labelName = input.getAttribute('label_name');
                console.log('üîç Checking input:', input.id, 'schema:', schema, 'label:', labelName);

                if (schema && labelName && currentAnnotations[schema] && currentAnnotations[schema][labelName]) {
                    input.value = currentAnnotations[schema][labelName];
                    console.log(`‚úÖ Populated ${input.tagName} ${input.id} with value:`, currentAnnotations[schema][labelName]);
                } else {
                    console.log(`‚ùå Could not populate ${input.tagName} ${input.id}:`, {
                        hasSchema: !!schema,
                        hasLabelName: !!labelName,
                        hasSchemaInAnnotations: !!(currentAnnotations[schema]),
                        hasLabelInSchema: !!(currentAnnotations[schema] && currentAnnotations[schema][labelName])
                    });
                }
            });

            // Populate radio buttons
            const radioInputs = document.querySelectorAll('input[type="radio"]');
            radioInputs.forEach(input => {
                const schema = input.getAttribute('schema');
                const labelName = input.getAttribute('label_name');

                if (schema && labelName && currentAnnotations[schema] && currentAnnotations[schema][labelName]) {
                    input.checked = (currentAnnotations[schema][labelName] === input.value);
                    console.log(`Populated radio ${input.id}: ${input.checked ? 'checked' : 'unchecked'}`);
                }
            });

            // Populate checkboxes
            const checkboxInputs = document.querySelectorAll('input[type="checkbox"]');
            checkboxInputs.forEach(input => {
                const schema = input.getAttribute('schema');
                const labelName = input.getAttribute('label_name');

                if (schema && labelName && currentAnnotations[schema]) {
                    // For checkboxes, check if the value exists in the annotations
                    const hasAnnotation = currentAnnotations[schema][labelName] === input.value;
                    input.checked = hasAnnotation;
                    console.log(`Populated checkbox ${input.id}: ${hasAnnotation ? 'checked' : 'unchecked'}`);
                }
            });

            // Populate sliders
            const sliderInputs = document.querySelectorAll('input[type="range"]');
            sliderInputs.forEach(input => {
                const schema = input.getAttribute('schema');
                const labelName = input.getAttribute('label_name');

                if (schema && labelName && currentAnnotations[schema] && currentAnnotations[schema][labelName]) {
                    input.value = currentAnnotations[schema][labelName];
                    const valueDisplay = document.getElementById(`${input.name}-value`);
                    if (valueDisplay) {
                        valueDisplay.textContent = currentAnnotations[schema][labelName];
                    }
                    console.log(`Populated slider ${input.id} with value:`, currentAnnotations[schema][labelName]);
                }
            });

            // Populate select dropdowns
            const selectInputs = document.querySelectorAll('select.annotation-input');
            selectInputs.forEach(input => {
                const schema = input.getAttribute('schema');
                const labelName = input.getAttribute('label_name');

                if (schema && labelName && currentAnnotations[schema] && currentAnnotations[schema][labelName]) {
                    input.value = currentAnnotations[schema][labelName];
                    console.log(`Populated select ${input.id} with value:`, currentAnnotations[schema][labelName]);
                }
            });

            // Populate number inputs
            const numberInputs = document.querySelectorAll('input[type="number"].annotation-input');
            numberInputs.forEach(input => {
                const schema = input.getAttribute('schema');
                const labelName = input.getAttribute('label_name');

                if (schema && labelName && currentAnnotations[schema] && currentAnnotations[schema][labelName]) {
                    input.value = currentAnnotations[schema][labelName];
                    console.log(`Populated number ${input.id} with value:`, currentAnnotations[schema][labelName]);
                }
            });
        }

        // Span annotation functions
        function onlyOne(checkbox) {
            var x = document.getElementsByClassName(checkbox.className);
            var i;
            for (i = 0; i < x.length; i++) {
                if (x[i].value != checkbox.value) x[i].checked = false;
            }
        }

        function changeSpanLabel(checkbox, schema, spanLabel, spanTitle, spanColor) {
            console.log('changeSpanLabel called:', {schema, spanLabel, spanTitle, spanColor, checked: checkbox.checked});
            // Listen for when the user has highlighted some text (only when the label is checked)
            document.onmouseup = function (e) {
                var senderElement = e.target;
                // Avoid the case where the user clicks the delete button
                if (senderElement.getAttribute("class") == "span_close") {
                    e.stopPropagation();
                    return true;
                }
                if (checkbox.checked) {
                    console.log('Mouse up event - checkbox is checked, calling surroundSelection');
                    surroundSelection(schema, spanLabel, spanTitle, spanColor);
                } else {
                    console.log('Mouse up event - checkbox is not checked');
                }
            };
        }

        function surroundSelection(schema, labelName, title, selectionColor) {
            console.log('surroundSelection called:', {schema, labelName, title, selectionColor});

            // Check that this wasn't a spurious click or the click for the delete button which
            // also seems to trigger this selection event
            if (window.getSelection().rangeCount == 0) {
                console.log('No selection range found');
                return;
            }
            var range = window.getSelection().getRangeAt(0);

            if (range.startOffset == range.endOffset) {
                console.log('Selection start and end offsets are the same');
                return;
            }

            // Get the instance id
            var instance_id = document.getElementById("instance_id").value;
            console.log('Instance ID:', instance_id);

            if (window.getSelection) {
                var sel = window.getSelection();

                // Check that we're labeling something in the instance text that
                // we want to annotate
                if (!sel.anchorNode.parentElement) {
                    console.log('No anchor node parent element');
                    return;
                }

                // Otherwise, we're going to be adding a new span annotation, if
                // the user has selected some non-empty part of the text
                if (sel.rangeCount && sel.toString().trim().length > 0) {
                    console.log('Valid selection found, creating span');

                    // Get the selection text as a string
                    var selText = window.getSelection().toString().trim();

                    // Get the start and end offsets of the selection
                    var range = sel.getRangeAt(0);
                    var start = range.startOffset;
                    var end = range.endOffset;

                    // Get the offsets for the server
                    startEnd = getSelectionIndices();
                    console.log('Selection indices:', startEnd);

                    // Package this all up in a post request to the server's updateinstance endpoint
                    var post_req = {
                        type: "span",
                        schema: schema,
                        state: [
                            {
                                name: labelName,
                                start: startEnd["start"],
                                end: startEnd["end"],
                                title: title,
                                value: selText
                            }
                        ],
                        instance_id: instance_id
                    };

                    console.log('Sending span annotation request:', post_req);

                    // Send the post request
                    fetch("/updateinstance", {
                        method: "POST",
                        body: JSON.stringify(post_req),
                        credentials: "same-origin",
                        headers: {
                            "Content-type": "application/json; charset=UTF-8",
                        },
                    }).then(response => {
                        if (response.ok) {
                            // Reload the page to show the new span
                            location.reload();
                        } else {
                            console.error('Failed to save span annotation');
                        }
                    });

                    // Clear the current selection
                    sel.empty();
                    console.log('Span creation request sent, page will reload');
                } else {
                    console.log('No valid selection found');
                }
            }
        }

        function deleteSpanAnnotation(spanElem, schema, labelName, title, start, end) {
            // Get the instance id
            var instance_id = document.getElementById("instance_id").value;

            // Package this all up in a post request to the server's updateinstance endpoint
            var post_req = {
                type: "span",
                schema: schema,
                state: [
                    {
                        name: labelName,
                        start: start,
                        end: end,
                        title: title,
                        value: null
                    }
                ],
                instance_id: instance_id
            };

            // Send the post request
            fetch("/updateinstance", {
                method: "POST",
                body: JSON.stringify(post_req),
                credentials: "same-origin",
                headers: {
                    "Content-type": "application/json; charset=UTF-8",
                },
            }).then(response => {
                if (response.ok) {
                    // Reload the page to show the updated spans
                    location.reload();
                } else {
                    console.error('Failed to delete span annotation');
                }
            });
        }

        function getSelectionIndices() {
            // Get the user selection
            var selection = window.getSelection();

            if (selection.rangeCount === 0) {
                return { start: -1, end: -1 }; // No selection
            }

            // Get the range object representing the selected portion
            var range = selection.getRangeAt(0);

            // Find the parent div element with id "instance-text" using jquery (v2 template structure)
            var parentDiv = $(range.commonAncestorContainer).closest('#instance-text')[0];

            if (!parentDiv) {
                return { start: -2, end: -2 }; // Not within a <div id="instance-text">
            }

            // Get the text content of the parent div
            var fullText = parentDiv.textContent || parentDiv.innerText;

            // Get the selected text
            var selectedText = selection.toString();

            // Find the start and end indices
            var startIndex = fullText.indexOf(selectedText);
            var endIndex = startIndex + selectedText.length;

            return { start: startIndex, end: endIndex };
        }

        // Extract all current span annotations from the DOM
        function extractSpanAnnotationsFromDOM() {
            // Instead of extracting from the DOM, return the global currentSpanAnnotations
            console.log('[DEBUG] extractSpanAnnotationsFromDOM: returning', currentSpanAnnotations.length, 'spans:', currentSpanAnnotations);
            return currentSpanAnnotations;
        }

        function restoreSpanAnnotationsFromHTML() {
            const instanceText = document.getElementById('instance-text');
            if (!instanceText) return;
            const spanElements = instanceText.querySelectorAll('.span-highlight');
            const found = [];
            spanElements.forEach(span => {
                const schema = span.getAttribute('schema');
                const name = span.getAttribute('data-label');
                const title = span.querySelector('.span_label')?.textContent || name;
                const onclick = span.querySelector('.span_close')?.getAttribute('onclick');
                let start = null, end = null;
                if (onclick) {
                    const match = onclick.match(/deleteSpanAnnotation\([^,]+,\s*'[^']+',\s*'[^']+',\s*'[^']+',\s*(\d+),\s*(\d+)\)/);
                    if (match) {
                        start = parseInt(match[1]);
                        end = parseInt(match[2]);
                    }
                }
                found.push({schema, name, title, start, end, value: span.textContent.replace(title, '').replace('√ó', '').trim()});
            });
            currentSpanAnnotations = found;
            console.log('[DEBUG] restoreSpanAnnotationsFromHTML: found', found.length, 'spans:', found);
        }

        // Function to save current annotations before navigation
        function saveAnnotationsBeforeNavigation() {
            console.log('=== SAVE ANNOTATIONS BEFORE NAVIGATION ===');

            // Get current instance ID
            const instanceId = document.getElementById('instance_id').value;
            console.log('Current instance ID:', instanceId);

            // Get current label annotations
            const labelAnnotations = {};
            document.querySelectorAll('input[name^="annotation_"]:checked').forEach(input => {
                const label = input.getAttribute('data-label');
                labelAnnotations[label] = true;
            });
            console.log('Current label annotations:', labelAnnotations);

            // Get current span annotations from DOM
            const currentSpans = [];
            document.querySelectorAll('.span-highlight').forEach(span => {
                const text = span.textContent;
                const label = span.getAttribute('data-label');
                const start = parseInt(span.getAttribute('data-start'));
                const end = parseInt(span.getAttribute('data-end'));
                currentSpans.push({ text, label, start, end });
            });
            console.log('Current spans from DOM:', currentSpans);

            // Also check global variable
            console.log('Global currentSpanAnnotations:', window.currentSpanAnnotations);

            // Use global variable if available, otherwise use DOM spans
            let spansToSave = window.currentSpanAnnotations || currentSpans;
            // Filter out invalid spans (missing start/end)
            const validSpans = spansToSave.filter(span => {
                const valid = typeof span.start === 'number' && typeof span.end === 'number' && !isNaN(span.start) && !isNaN(span.end);
                if (!valid) {
                    console.warn('Filtering out invalid span annotation:', span);
                }
                return valid;
            });
            console.log('Spans to save (filtered):', validSpans);

            // Prepare data to send
            const data = {
                instance_id: instanceId,
                annotations: labelAnnotations,
                span_annotations: validSpans
            };
            console.log('Data to send to backend:', data);

            // Send to backend
            fetch('/updateinstance', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(data)
            })
            .then(response => response.json())
            .then(result => {
                console.log('Save response:', result);
            })
            .catch(error => {
                console.error('Error saving annotations:', error);
            });
        }

        // Function to restore annotations after navigation
        function restoreAnnotations() {
            console.log('=== RESTORE ANNOTATIONS ===');

            // Get current instance ID
            const instanceId = document.getElementById('instance_id').value;
            console.log('Restoring for instance ID:', instanceId);

            if (!instanceId) {
                console.log('No instance ID found, skipping restoration');
                return;
            }

            // Get annotations from backend
            fetch(`/get_annotations?instance_id=${instanceId}`)
            .then(response => {
                console.log('get_annotations response status:', response.status);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                return response.json();
            })
            .then(data => {
                console.log('Backend annotation data:', data);

                // Restore label annotations
                if (data.annotations) {
                    console.log('Restoring label annotations:', data.annotations);
                    Object.keys(data.annotations).forEach(label => {
                        const input = document.querySelector(`input[data-label="${label}"]`);
                        if (input) {
                            input.checked = true;
                            console.log('Checked label:', label);
                        } else {
                            console.log('Label input not found:', label);
                        }
                    });
                }

                // Restore span annotations
                if (data.span_annotations && data.span_annotations.length > 0) {
                    console.log('Restoring span annotations:', data.span_annotations);

                    // Clear existing spans
                    document.querySelectorAll('.span-highlight').forEach(span => {
                        span.remove();
                    });

                    // Add new spans
                    data.span_annotations.forEach(spanData => {
                        console.log('Adding span:', spanData);
                        surroundSelection(spanData.text, spanData.label, spanData.start, spanData.end);
                    });

                    // Update global variable
                    window.currentSpanAnnotations = data.span_annotations;
                    console.log('Updated global currentSpanAnnotations:', window.currentSpanAnnotations);
                } else {
                    console.log('No span annotations to restore');
                    window.currentSpanAnnotations = [];
                }

                console.log('Restoration complete');
            })
            .catch(error => {
                console.error('Error restoring annotations:', error);
            });
        }

        // Enhanced navigation functions with better logging
        function navigateToInstance(instanceId) {
            console.log('=== NAVIGATE TO INSTANCE ===');
            console.log('Navigating to instance ID:', instanceId);

            // Save current annotations first
            saveAnnotationsBeforeNavigation();

            // Wait a bit for save to complete, then navigate
            setTimeout(() => {
                console.log('Proceeding with navigation...');
                window.location.href = `/annotate?instance_id=${instanceId}`;
            }, 500);
        }

                // Enhanced button event listeners
        document.addEventListener('DOMContentLoaded', function() {
            console.log('=== DOM CONTENT LOADED ===');

            // Set up navigation buttons
            const prevBtn = document.getElementById('prev-btn');
            const nextBtn = document.getElementById('next-btn');

            if (prevBtn) {
                prevBtn.addEventListener('click', function() {
                    console.log('Previous button clicked');
                    const currentId = document.getElementById('instance_id').value;
                    console.log('Current ID:', currentId);

                    // Get previous instance ID (this would need to be implemented based on your data structure)
                    const prevId = getPreviousInstanceId(currentId);
                    console.log('Previous ID:', prevId);

                    if (prevId) {
                        navigateToInstance(prevId);
                    }
                });
            }

            if (nextBtn) {
                nextBtn.addEventListener('click', function() {
                    console.log('Next button clicked');
                    const currentId = document.getElementById('instance_id').value;
                    console.log('Current ID:', currentId);

                    // Get next instance ID (this would need to be implemented based on your data structure)
                    const nextId = getNextInstanceId(currentId);
                    console.log('Next ID:', nextId);

                    if (nextId) {
                        navigateToInstance(nextId);
                    }
                });
            }

            // Restore annotations on page load after a short delay to ensure DOM is ready
            setTimeout(() => {
                console.log('Calling restoreAnnotations...');
                restoreAnnotations();
            }, 1000);
        });

        // Helper functions for navigation (these would need to be implemented based on your data structure)
        function getPreviousInstanceId(currentId) {
            // This is a placeholder - implement based on your instance ordering
            const instances = ['ai_1', 'sad_2', 'happy_3', 'angry_4'];
            const currentIndex = instances.indexOf(currentId);
            if (currentIndex > 0) {
                return instances[currentIndex - 1];
            }
            return null;
        }

        function getNextInstanceId(currentId) {
            // This is a placeholder - implement based on your instance ordering
            const instances = ['ai_1', 'sad_2', 'happy_3', 'angry_4'];
            const currentIndex = instances.indexOf(currentId);
            if (currentIndex < instances.length - 1) {
                return instances[currentIndex + 1];
            }
            return null;
        }
    </script>
</body>
</html>