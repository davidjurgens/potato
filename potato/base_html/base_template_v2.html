<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{annotation_task_name}}</title>

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

    <!-- Custom Styles -->
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
</head>

<body>
    <!-- Hidden fields for server communication -->
    <input type="hidden" name="username" id="username" value="{{username}}" />
    <input type="hidden" name="instance_id" id="instance_id" value="{{instance_id}}" />
    <input type="hidden" name="alert_time_each_instance" id="alert_time_each_instance" value="{{alert_time_each_instance}}" />

    <!-- Header navigation bar -->
    <nav class="navbar sticky-top shadow-sm" style="background-color: var(--primary-color); padding: 0.75rem 1rem; margin-bottom: 1.5rem;">
        <div class="container-fluid d-flex align-items-center">
            <!-- Task name (left aligned) -->
            <div class="navbar-brand">
                <span class="fw-bold" style="color: var(--light-color); font-size: 1.25rem">{{annotation_task_name}}</span>
            </div>

            <!-- Middle section with progress and navigation -->
            <div class="d-flex align-items-center justify-content-center flex-grow-1 gap-4">
                <!-- Progress counter -->
                <div class="d-flex align-items-center" style="color: var(--light-color); margin-right: 40px">
                    <span>Progress: <span class="fw-medium" id="progress-counter">0/0</span></span>
                </div>

                <!-- Jump to item form -->
                <div style="margin-left: 40px">
                    <div class="d-flex align-items-center">
                        <label for="go_to" class="me-2" style="color: var(--light-color); margin-bottom: 0">Go to:</label>
                        <input type="number" id="go_to" class="form-control form-control-sm me-2"
                               style="width: 70px; height: 31px; border: none; border-radius: var(--radius);"
                               value="" min="0" required>
                        <button type="button" class="shadcn-button" id="go-to-btn"
                                style="height: 31px; line-height: 1; padding: 0 0.75rem; background-color: var(--light-color); color: var(--primary-color); border: none;">
                            Go
                        </button>
                    </div>
                </div>
            </div>

            <!-- User info and logout (right aligned) -->
            <div class="d-flex align-items-center"
                 style="background-color: rgba(255, 255, 255, 0.15); padding: 0.5rem 1rem; border-radius: var(--radius);">
                <div class="me-3" style="color: var(--light-color)">
                    <span>Logged in as <span class="fw-medium" id="username-display">{{username}}</span></span>
                </div>
                <div class="border-start" style="padding-left: 20px; height: 24px; display: flex; align-items: center;">
                    <a href="/logout" class="shadcn-button"
                       style="background-color: var(--light-color); color: var(--primary-color); height: auto; padding: 0.25rem 0.75rem !important; font-size: 0.875rem; min-width: 60px; text-align: center; border: none; text-decoration: none;">
                        Logout
                    </a>
                </div>
            </div>
        </div>
    </nav>

    <div class="container-fluid">
        <!-- Main annotation area -->
        <div id="task_layout" class="shadcn-card mb-4">
            <div class="shadcn-card-content">
                <!-- Loading state -->
                <div id="loading-state" class="text-center py-5">
                    <div class="loading-spinner mb-3"></div>
                    <p>Loading annotation interface...</p>
                </div>

                <!-- Error state -->
                <div id="error-state" class="error-message" style="display: none;">
                    <h5><i class="fas fa-exclamation-triangle me-2"></i>Error</h5>
                    <p id="error-message-text"></p>
                    <button class="shadcn-button shadcn-button-primary" onclick="loadCurrentInstance()">
                        <i class="fas fa-redo me-2"></i>Retry
                    </button>
                </div>

                <!-- Main content area -->
                <div id="main-content" style="display: none;">
                    <!-- Instance text -->
                    <div class="mb-4">
                        <h5 class="mb-3">Text to Annotate:</h5>
                        <div id="instance-text" class="p-3 border rounded" style="background-color: var(--light-bg); min-height: 100px;">
                            <!-- Instance text will be loaded here -->
                        </div>
                    </div>

                    <!-- Annotation forms -->
                    <div id="annotation-forms">
                      <!-- TEMPLATE_MARKER: This should appear in the HTML if the correct template is used -->
                      {{ TASK_LAYOUT|safe }}
                    </div>
                </div>
            </div>
        </div>

        <!-- Navigation buttons -->
        <div class="my-4">
            <div class="d-flex justify-content-between align-items-center">
                <!-- Previous button -->
                <div>
                    <button class="shadcn-button shadcn-button-outline me-2" id="prev-btn" onclick="navigateToPrevious()">
                        <i class="fas fa-arrow-left me-2"></i>Previous
                    </button>
                </div>

                <!-- Next button -->
                <div>
                    <button class="shadcn-button shadcn-button-primary" id="next-btn" onclick="navigateToNext()">
                        Next<i class="fas fa-arrow-right ms-2"></i>
                    </button>
                </div>
            </div>
        </div>

        <!-- Footer -->
        <hr style="color: var(--border)">
        <footer class="py-2 text-center" style="font-size: 0.75rem; color: var(--muted-foreground)">
            Copyright &copy; 2025
            <a href="https://blablablab.si.umich.edu/" style="color: var(--primary); text-decoration: none">Blablablab</a>
            <span class="mx-2">|</span>
            <a href="https://github.com/davidjurgens/potato" style="color: var(--primary); text-decoration: none">Chat with us on GitHub</a>
            <span class="mx-2">|</span>
            <a href="https://github.com/davidjurgens/potato#cite-us" style="color: var(--primary); text-decoration: none">Cite Us</a>
        </footer>
    </div>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>

    <!-- jQuery (required for span annotation) -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>

    <!-- Configuration from server -->
    <script>
        window.config = {
            annotation_task_name: "{{ annotation_task_name }}",
            debug: {{ debug | tojson | safe }}
        };
    </script>

    <script>
        // Global state
        let currentInstance = null;
        let currentAnnotations = {};
        let userState = null;
        let isLoading = false;
        let textSaveTimer = null;

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            loadCurrentInstance();
            setupEventListeners();
        });

        function setupEventListeners() {
            // Go to button
            document.getElementById('go-to-btn').addEventListener('click', function() {
                const goToValue = document.getElementById('go_to').value;
                if (goToValue && goToValue > 0) {
                    navigateToInstance(parseInt(goToValue));
                }
            });

            // Enter key on go to input
            document.getElementById('go_to').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    document.getElementById('go-to-btn').click();
                }
            });

            // Keyboard navigation
            document.addEventListener('keydown', function(e) {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                    return; // Don't handle navigation when typing
                }

                switch(e.key) {
                    case 'ArrowLeft':
                        e.preventDefault();
                        navigateToPrevious();
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        navigateToNext();
                        break;
                }
            });

            // Span annotation event listeners
            setupSpanAnnotationListeners();
        }

        function setupSpanAnnotationListeners() {
            // Add event listeners for span annotation checkboxes
            const spanCheckboxes = document.querySelectorAll('input[for_span="true"]');
            spanCheckboxes.forEach(checkbox => {
                checkbox.addEventListener('change', function() {
                    console.log('Span checkbox changed:', this);

                    // Get the schema and label from the checkbox attributes or surrounding elements
                    const schema = this.getAttribute('name')?.split(':::')[1] || this.closest('fieldset')?.getAttribute('schema');
                    const value = this.value;

                    // Map value to label name (this is a simplified mapping - in practice you'd need to get this from the config)
                    const labelMappings = {
                        'emotion': {
                            '1': 'happy', '2': 'sad', '3': 'angry', '4': 'surprised', '5': 'neutral'
                        },
                        'intensity': {
                            '1': 'low', '2': 'medium', '3': 'high'
                        }
                    };

                    const labelName = labelMappings[schema]?.[value] || value;
                    const color = this.closest('.shadcn-span-option')?.querySelector('span')?.style.backgroundColor || '(255, 230, 230)';

                    console.log('Calling changeSpanLabel with:', {schema, labelName, color, checked: this.checked});

                    // Call the span annotation functions
                    if (typeof onlyOne === 'function') {
                        onlyOne(this);
                    }
                    if (typeof changeSpanLabel === 'function') {
                        changeSpanLabel(this, schema, labelName, labelName, color);
                    }
                });
            });
        }

        // Add validation for annotation form
        function validateAnnotationForm() {
            // Find all required annotation inputs (radio, checkbox, text, select, etc.)
            const requiredInputs = document.querySelectorAll('.annotation-input[validation="required"]');
            let allFilled = true;
            let radioGroups = {};

            requiredInputs.forEach(input => {
                const type = input.type;
                if (type === 'radio') {
                    // Group radios by name
                    if (!radioGroups[input.name]) radioGroups[input.name] = [];
                    radioGroups[input.name].push(input);
                } else if (type === 'checkbox') {
                    // At least one required checkbox in group must be checked
                    if (!input.checked) allFilled = false;
                } else if (type === 'text' || type === 'number' || input.tagName.toLowerCase() === 'textarea' || input.tagName.toLowerCase() === 'select') {
                    if (!input.value) allFilled = false;
                }
            });
            // Check radio groups
            for (const groupName in radioGroups) {
                const group = radioGroups[groupName];
                if (!group.some(r => r.checked)) allFilled = false;
            }
            // Enable/disable Next button
            const nextBtn = document.getElementById('next-btn');
            nextBtn.disabled = !allFilled;
        }

        function setupInputEventListeners() {
            // Set up event listeners for all annotation inputs
            const inputs = document.querySelectorAll('.annotation-input');

            inputs.forEach(input => {
                const inputType = input.type;
                const tagName = input.tagName.toLowerCase();

                if (inputType === 'text' || tagName === 'textarea') {
                    let timer;
                    input.addEventListener('input', function(event) {
                        clearTimeout(timer);
                        timer = setTimeout(() => {
                            handleInputChange(event.target);
                            validateAnnotationForm();
                        }, 1000);
                    });
                } else if (inputType === 'radio' || inputType === 'checkbox') {
                    input.addEventListener('change', function(event) {
                        handleInputChange(event.target);
                        validateAnnotationForm();
                    });
                } else if (inputType === 'range') {
                    input.addEventListener('input', function(event) {
                        const valueDisplay = document.getElementById(`${input.name}-value`);
                        if (valueDisplay) {
                            valueDisplay.textContent = event.target.value;
                        }
                        handleInputChange(event.target);
                        validateAnnotationForm();
                    });
                } else if (tagName === 'select') {
                    input.addEventListener('change', function(event) {
                        handleInputChange(event.target);
                        validateAnnotationForm();
                    });
                } else if (inputType === 'number') {
                    let timer;
                    input.addEventListener('input', function(event) {
                        clearTimeout(timer);
                        timer = setTimeout(() => {
                            handleInputChange(event.target);
                            validateAnnotationForm();
                        }, 1000);
                    });
                }
            });
            // Initial validation
            validateAnnotationForm();
        }

        async function loadCurrentInstance() {
            try {
                setLoading(true);
                showError(false);

                // Get current user state
                const response = await fetch('/test/user_state/{{username}}');
                if (!response.ok) {
                    throw new Error('Failed to load user state');
                }

                userState = await response.json();

                if (!userState.current_instance) {
                    showError(true, 'No instances available for annotation');
                    return;
                }

                currentInstance = userState.current_instance;
                updateProgressDisplay();
                updateInstanceDisplay();
                loadAnnotations();
                generateAnnotationForms();
                setTimeout(() => {
                    populateInputValues();
                    validateAnnotationForm(); // <-- validate after populating
                }, 0);

            } catch (error) {
                console.error('Error loading current instance:', error);
                showError(true, error.message);
            } finally {
                setLoading(false);
            }
        }

        function updateProgressDisplay() {
            const progress = userState.assignments;
            const progressText = `${progress.annotated}/${progress.total}`;
            document.getElementById('progress-counter').textContent = progressText;
        }

        function updateInstanceDisplay() {
            const instanceText = document.getElementById('instance-text');
            if (currentInstance && currentInstance.displayed_text) {
                instanceText.innerHTML = currentInstance.displayed_text;
            } else {
                instanceText.textContent = 'No text available';
            }
        }

        async function loadAnnotations() {
            try {
                const rawAnnotations = userState.annotations.by_instance[currentInstance.id] || {};

                // Transform the server format to frontend format
                // Server format: {"Label(schema:sentiment, name:neutral)": "true"}
                // Frontend format: {"sentiment": {"neutral": "true"}}
                currentAnnotations = {};

                for (const [labelKey, value] of Object.entries(rawAnnotations)) {
                    // Parse the label key format: "Label(schema:sentiment, name:neutral)"
                    const match = labelKey.match(/Label\(schema:([^,]+), name:([^)]+)\)/);
                    if (match) {
                        const schemaName = match[1];
                        const labelName = match[2];

                        if (!currentAnnotations[schemaName]) {
                            currentAnnotations[schemaName] = {};
                        }
                        currentAnnotations[schemaName][labelName] = value;
                    } else {
                        // Handle direct key-value pairs (fallback)
                        console.warn('Could not parse annotation key:', labelKey);
                    }
                }

                console.log('Loaded annotations for instance', currentInstance.id, ':', currentAnnotations);
            } catch (error) {
                console.error('Error loading annotations:', error);
                currentAnnotations = {};
            }
        }

        function generateAnnotationForms() {
            const formsContainer = document.getElementById('annotation-forms');

            // The server generates the forms, so we just need to set up event listeners
            // The forms are already in the HTML from server-side generation
            setupInputEventListeners();
        }











        async function saveAnnotations() {
            if (!currentInstance) return;

            try {
                // Convert frontend format to server format
                const formData = new FormData();
                formData.append('instance_id', currentInstance.id);
                formData.append('annotation_data', JSON.stringify(currentAnnotations));

                const response = await fetch('/submit_annotation', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    throw new Error('Failed to save annotations');
                }

                const result = await response.json();
                console.log('Annotations saved:', result);
                return true;

            } catch (error) {
                console.error('Error saving annotations:', error);
                showError(true, 'Failed to save annotations: ' + error.message);
                return false;
            }
        }

        async function navigateToPrevious() {
            if (isLoading) return;

            try {
                setLoading(true);
                const response = await fetch('/annotate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        action: 'prev_instance',
                        instance_id: currentInstance?.id
                    })
                });

                if (response.ok) {
                    await loadCurrentInstance();
                } else {
                    throw new Error('Failed to navigate to previous instance');
                }
            } catch (error) {
                console.error('Error navigating to previous:', error);
                showError(true, error.message);
            } finally {
                setLoading(false);
            }
        }

        async function navigateToNext() {
            if (isLoading) return;

            // Save current annotations before navigating
            const saved = await saveAnnotations();
            if (!saved) return;

            try {
                setLoading(true);
                const response = await fetch('/annotate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        action: 'next_instance',
                        instance_id: currentInstance?.id
                    })
                });

                if (response.ok) {
                    await loadCurrentInstance();
                } else {
                    throw new Error('Failed to navigate to next instance');
                }
            } catch (error) {
                console.error('Error navigating to next:', error);
                showError(true, error.message);
            } finally {
                setLoading(false);
            }
        }

        async function navigateToInstance(instanceIndex) {
            if (isLoading) return;

            try {
                setLoading(true);
                const response = await fetch('/annotate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        action: 'go_to',
                        go_to: instanceIndex
                    })
                });

                if (response.ok) {
                    await loadCurrentInstance();
                } else {
                    throw new Error('Failed to navigate to instance');
                }
            } catch (error) {
                console.error('Error navigating to instance:', error);
                showError(true, error.message);
            } finally {
                setLoading(false);
            }
        }

        function setLoading(loading) {
            isLoading = loading;
            const loadingState = document.getElementById('loading-state');
            const mainContent = document.getElementById('main-content');
            const prevBtn = document.getElementById('prev-btn');
            const nextBtn = document.getElementById('next-btn');

            if (loading) {
                loadingState.style.display = 'block';
                mainContent.style.display = 'none';
                prevBtn.disabled = true;
                nextBtn.disabled = true;
            } else {
                loadingState.style.display = 'none';
                mainContent.style.display = 'block';
                prevBtn.disabled = false;
                nextBtn.disabled = false;
            }
        }

        function showError(show, message = '') {
            const errorState = document.getElementById('error-state');
            const errorMessage = document.getElementById('error-message-text');
            const mainContent = document.getElementById('main-content');

            if (show) {
                errorState.style.display = 'block';
                mainContent.style.display = 'none';
                errorMessage.textContent = message;
            } else {
                errorState.style.display = 'none';
                mainContent.style.display = 'block';
            }
        }

        // Utility functions for annotation handling
        function updateAnnotation(schema, label, value) {
            if (!currentAnnotations[schema]) {
                currentAnnotations[schema] = {};
            }
            currentAnnotations[schema][label] = value;
        }

        // Function to handle "None" option in multiselect annotations
        function whetherNone(checkbox) {
            // This function is used to uncheck all the other labels when "None" is checked
            // and vice versa
            var x = document.getElementsByClassName(checkbox.className);
            var i;
            for (i = 0; i < x.length; i++) {
                if(checkbox.value == "None" && x[i].value != "None") x[i].checked = false;
                if(checkbox.value != "None" && x[i].value == "None") x[i].checked = false;
            }
            // Also trigger the input change handler for the current checkbox
            handleInputChange(checkbox);
        }

        // Input event handling functions
        function handleInputChange(element) {
            const schema = element.getAttribute('schema');
            const labelName = element.getAttribute('label_name');
            const inputType = element.type;
            const tagName = element.tagName.toLowerCase();

            console.log(`handleInputChange called for ${tagName} element:`, element.id, 'schema:', schema, 'label:', labelName);

            if (!schema || !labelName) {
                console.warn('Missing schema or label_name for input:', element);
                return;
            }

            let value;

            if (inputType === 'radio') {
                // For radio buttons, only save if checked
                if (element.checked) {
                    value = element.value;
                } else {
                    return; // Don't save unchecked radio buttons
                }
            } else if (inputType === 'checkbox') {
                // For checkboxes, save the checked state
                if (element.checked) {
                    value = element.value;
                } else {
                    // For unchecked checkboxes, remove the annotation or set to false
                    if (currentAnnotations[schema] && currentAnnotations[schema][labelName]) {
                        delete currentAnnotations[schema][labelName];
                        // If the schema is empty, remove it too
                        if (Object.keys(currentAnnotations[schema]).length === 0) {
                            delete currentAnnotations[schema];
                        }
                    }
                    console.log(`Removed annotation: ${schema}.${labelName}`);

                    // Auto-save the removal
                    clearTimeout(textSaveTimer);
                    textSaveTimer = setTimeout(() => {
                        saveAnnotations();
                    }, 500);
                    return;
                }
            } else {
                // For text inputs, save the value
                value = element.value;
            }

            // Update the current annotations
            updateAnnotation(schema, labelName, value);
            console.log(`Updated annotation: ${schema}.${labelName} = ${value}`);

            // Auto-save
            clearTimeout(textSaveTimer);
            textSaveTimer = setTimeout(() => {
                saveAnnotations();
            }, 500);
        }

        function populateInputValues() {
            if (!currentAnnotations || !userState) return;

            console.log('Populating input values with annotations:', currentAnnotations);

            // Populate text inputs and textareas
            const textInputs = document.querySelectorAll('input[type="text"], textarea.annotation-input');
            textInputs.forEach(input => {
                const schema = input.getAttribute('schema');
                const labelName = input.getAttribute('label_name');

                if (schema && labelName && currentAnnotations[schema] && currentAnnotations[schema][labelName]) {
                    input.value = currentAnnotations[schema][labelName];
                    console.log(`Populated ${input.tagName} ${input.id} with value:`, currentAnnotations[schema][labelName]);
                }
            });

            // Populate radio buttons
            const radioInputs = document.querySelectorAll('input[type="radio"]');
            radioInputs.forEach(input => {
                const schema = input.getAttribute('schema');
                const labelName = input.getAttribute('label_name');

                if (schema && labelName && currentAnnotations[schema] && currentAnnotations[schema][labelName]) {
                    input.checked = (currentAnnotations[schema][labelName] === input.value);
                    console.log(`Populated radio ${input.id}: ${input.checked ? 'checked' : 'unchecked'}`);
                }
            });

            // Populate checkboxes
            const checkboxInputs = document.querySelectorAll('input[type="checkbox"]');
            checkboxInputs.forEach(input => {
                const schema = input.getAttribute('schema');
                const labelName = input.getAttribute('label_name');

                if (schema && labelName && currentAnnotations[schema]) {
                    // For checkboxes, check if the value exists in the annotations
                    const hasAnnotation = currentAnnotations[schema][labelName] === input.value;
                    input.checked = hasAnnotation;
                    console.log(`Populated checkbox ${input.id}: ${hasAnnotation ? 'checked' : 'unchecked'}`);
                }
            });

            // Populate sliders
            const sliderInputs = document.querySelectorAll('input[type="range"]');
            sliderInputs.forEach(input => {
                const schema = input.getAttribute('schema');
                const labelName = input.getAttribute('label_name');

                if (schema && labelName && currentAnnotations[schema] && currentAnnotations[schema][labelName]) {
                    input.value = currentAnnotations[schema][labelName];
                    const valueDisplay = document.getElementById(`${input.name}-value`);
                    if (valueDisplay) {
                        valueDisplay.textContent = currentAnnotations[schema][labelName];
                    }
                    console.log(`Populated slider ${input.id} with value:`, currentAnnotations[schema][labelName]);
                }
            });

            // Populate select dropdowns
            const selectInputs = document.querySelectorAll('select.annotation-input');
            selectInputs.forEach(input => {
                const schema = input.getAttribute('schema');
                const labelName = input.getAttribute('label_name');

                if (schema && labelName && currentAnnotations[schema] && currentAnnotations[schema][labelName]) {
                    input.value = currentAnnotations[schema][labelName];
                    console.log(`Populated select ${input.id} with value:`, currentAnnotations[schema][labelName]);
                }
            });

            // Populate number inputs
            const numberInputs = document.querySelectorAll('input[type="number"].annotation-input');
            numberInputs.forEach(input => {
                const schema = input.getAttribute('schema');
                const labelName = input.getAttribute('label_name');

                if (schema && labelName && currentAnnotations[schema] && currentAnnotations[schema][labelName]) {
                    input.value = currentAnnotations[schema][labelName];
                    console.log(`Populated number ${input.id} with value:`, currentAnnotations[schema][labelName]);
                }
            });
        }

        // Span Annotation Functions
        function onlyOne(checkbox) {
            // This function is used for the single-choice setting
            var x = document.getElementsByClassName(checkbox.className);
            var i;
            for (i = 0; i < x.length; i++) {
                if (x[i].value != checkbox.value) x[i].checked = false;
            }
        }

        function changeSpanLabel(checkbox, schema, spanLabel, spanTitle, spanColor) {
            console.log('changeSpanLabel called:', {schema, spanLabel, spanTitle, spanColor, checked: checkbox.checked});
            // Listen for when the user has highlighted some text (only when the label is checked)
            document.onmouseup = function (e) {
                var senderElement = e.target;
                // Avoid the case where the user clicks the delete button
                if (senderElement.getAttribute("class") == "span_close") {
                    e.stopPropagation();
                    return true;
                }
                if (checkbox.checked) {
                    console.log('Mouse up event - checkbox is checked, calling surroundSelection');
                    surroundSelection(schema, spanLabel, spanTitle, spanColor);
                } else {
                    console.log('Mouse up event - checkbox is not checked');
                }
            };
        }

        function surroundSelection(schema, labelName, title, selectionColor) {
            console.log('surroundSelection called:', {schema, labelName, title, selectionColor});

            // Check that this wasn't a spurious click or the click for the delete button which
            // also seems to trigger this selection event
            if (window.getSelection().rangeCount == 0) {
                console.log('No selection range found');
                return;
            }
            var range = window.getSelection().getRangeAt(0);

            if (range.startOffset == range.endOffset) {
                console.log('Selection start and end offsets are the same');
                return;
            }

            // Get the instance id
            var instance_id = document.getElementById("instance_id").value;
            console.log('Instance ID:', instance_id);

            if (window.getSelection) {
                var sel = window.getSelection();

                // Check that we're labeling something in the instance text that
                // we want to annotate
                if (!sel.anchorNode.parentElement) {
                    console.log('No anchor node parent element');
                    return;
                }

                // Otherwise, we're going to be adding a new span annotation, if
                // the user has selected some non-empty part of the text
                if (sel.rangeCount && sel.toString().trim().length > 0) {
                    console.log('Valid selection found, creating span');

                    // Get the selection text as a string
                    var selText = window.getSelection().toString().trim();

                    // Get the start and end offsets of the selection
                    var range = sel.getRangeAt(0);
                    var start = range.startOffset;
                    var end = range.endOffset;

                    // Get the offsets for the server
                    startEnd = getSelectionIndices();
                    console.log('Selection indices:', startEnd);

                    // Package this all up in a post request to the server's updateinstance endpoint
                    var post_req = {
                        type: "span",
                        schema: schema,
                        state: [
                            {
                                name: labelName,
                                start: startEnd["start"],
                                end: startEnd["end"],
                                title: title,
                                value: selText
                            }
                        ],
                        instance_id: instance_id
                    };

                    console.log('Sending span annotation request:', post_req);

                    // Send the post request
                    fetch("/updateinstance", {
                        method: "POST",
                        body: JSON.stringify(post_req),
                        credentials: "same-origin",
                        headers: {
                            "Content-type": "application/json; charset=UTF-8",
                        },
                    }).then(response => {
                        if (response.ok) {
                            // Reload the page to show the new span
                            location.reload();
                        } else {
                            console.error('Failed to save span annotation');
                        }
                    });

                    // Clear the current selection
                    sel.empty();
                    console.log('Span creation request sent, page will reload');
                } else {
                    console.log('No valid selection found');
                }
            }
        }

        function deleteSpanAnnotation(spanElem, schema, labelName, title, start, end) {
            // Get the instance id
            var instance_id = document.getElementById("instance_id").value;

            // Package this all up in a post request to the server's updateinstance endpoint
            var post_req = {
                type: "span",
                schema: schema,
                state: [
                    {
                        name: labelName,
                        start: start,
                        end: end,
                        title: title,
                        value: null
                    }
                ],
                instance_id: instance_id
            };

            // Send the post request
            fetch("/updateinstance", {
                method: "POST",
                body: JSON.stringify(post_req),
                credentials: "same-origin",
                headers: {
                    "Content-type": "application/json; charset=UTF-8",
                },
            }).then(response => {
                if (response.ok) {
                    // Reload the page to show the updated spans
                    location.reload();
                } else {
                    console.error('Failed to delete span annotation');
                }
            });
        }

        function getEarlierChildren(n, skipMe) {
            var r = [];
            for (; n; n = n.nextSibling)
                if (n.nodeType == 1 && n != skipMe) r.push(n);
                else if (n == skipMe) break;
            return r;
        }

        function getEarlierSiblings(n) {
            return getEarlierChildren(n.parentNode.firstChild, n);
        }

        function getTextOfSpans(elems) {
            text = "";
            for (i = 0; i < elems.length; i++) {
                e = elems[i].cloneNode(true);
                // Delete all the nested <div> elements with jquery to get the plain text
                $(e).find("div").remove();
                text += " " + e.textContent;
            }
            return text.trim();
        }

        function getSelectionIndices() {
            // Get the user selection
            var selection = window.getSelection();

            if (selection.rangeCount === 0) {
                return { start: -1, end: -1 }; // No selection
            }

            // Get the range object representing the selected portion
            var range = selection.getRangeAt(0);

            // Find the parent div element with id "instance-text" using jquery (v2 template structure)
            var parentDiv = $(range.commonAncestorContainer).closest('#instance-text')[0];

            if (!parentDiv) {
                return { start: -2, end: -2 }; // Not within a <div id="instance-text">
            }

            // Get the text content of the parent div
            var fullText = parentDiv.textContent || parentDiv.innerText;

            // Get the selected text
            var selectedText = selection.toString();

            // Find the start position by looking for the selected text in the full text
            var startPos = fullText.indexOf(selectedText);

            if (startPos === -1) {
                // If exact match not found, try to find a partial match
                startPos = 0;
            }

            var endPos = startPos + selectedText.length;

            console.log('getSelectionIndices - fullText:', fullText);
            console.log('getSelectionIndices - selectedText:', selectedText);
            console.log('getSelectionIndices - startPos:', startPos, 'endPos:', endPos);

            return { start: startPos, end: endPos };
        }
    </script>
    <div id="annotated-text-container" style="position: relative; width: 100%;">
      <div id="instance-text" style="position: relative; font-family: inherit;">{{ instance|safe }}</div>
      {{ span_script|safe }}
      <div id="span-overlays" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></div>
    </div>
    <script>
(function() {
  function clearOverlays() {
    const overlays = document.getElementById('span-overlays');
    if (overlays) overlays.innerHTML = '';
  }

  function renderSpanOverlays() {
    console.log('üîç renderSpanOverlays called');
    clearOverlays();
    const overlays = document.getElementById('span-overlays');
    const textDiv = document.getElementById('instance-text');

    console.log('üîç overlays element:', overlays);
    console.log('üîç textDiv element:', textDiv);
    console.log('üîç window.spanAnnotations:', window.spanAnnotations);

    if (!overlays) {
      console.error('‚ùå span-overlays element not found');
      return;
    }
    if (!textDiv) {
      console.error('‚ùå instance-text element not found');
      return;
    }
    if (!window.spanAnnotations) {
      console.error('‚ùå window.spanAnnotations not found');
      return;
    }

    console.log('üîç textDiv.innerHTML:', textDiv.innerHTML);
    console.log('üîç textDiv.textContent:', textDiv.textContent);
    console.log('üîç textDiv.childNodes.length:', textDiv.childNodes.length);

    // Find the actual text node - it might not be the first child
    let textNode = null;
    for (let i = 0; i < textDiv.childNodes.length; i++) {
      const node = textDiv.childNodes[i];
      console.log(`üîç child ${i}:`, node.nodeType, node.nodeName, node.textContent?.substring(0, 50));
      if (node.nodeType === Node.TEXT_NODE && node.textContent.trim()) {
        textNode = node;
        console.log('üîç Found text node at index', i);
        break;
      }
    }

    if (!textNode) {
      console.error('‚ùå No text node found in instance-text');
      return;
    }

    console.log('üîç textNode.textContent:', textNode.textContent);
    console.log('üîç textNode.length:', textNode.length);

    window.spanAnnotations.forEach((span, idx) => {
      console.log(`üîç Processing span ${idx}:`, span);
      try {
        const range = document.createRange();
        range.setStart(textNode, span.start);
        range.setEnd(textNode, span.end);
        console.log(`üîç Created range from ${span.start} to ${span.end}`);

        const rects = range.getClientRects();
        console.log(`üîç Got ${rects.length} client rects for span ${idx}`);

        Array.from(rects).forEach((rect, rectIdx) => {
          console.log(`üîç Processing rect ${rectIdx}:`, rect);
          const overlay = document.createElement('div');
          overlay.className = 'span-overlay';
          overlay.style.position = 'absolute';
          overlay.style.left = (rect.left - textDiv.getBoundingClientRect().left + textDiv.scrollLeft) + 'px';
          overlay.style.top = (rect.top - textDiv.getBoundingClientRect().top + textDiv.scrollTop) + 'px';
          overlay.style.width = rect.width + 'px';
          overlay.style.height = rect.height + 'px';
          overlay.style.background = span.color;
          overlay.style.border = '2px solid rgb' + span.border_rgb;
          overlay.style.zIndex = 10 + idx;
          overlay.style.pointerEvents = 'auto';
          overlay.style.boxSizing = 'border-box';

          // Label
          const label = document.createElement('div');
          label.className = 'span-label';
          label.textContent = span.title;
          label.style.position = 'absolute';
          label.style.top = '-20px';
          label.style.left = '0';
          label.style.background = 'white';
          label.style.border = '1px solid rgb' + span.border_rgb;
          label.style.fontSize = '12px';
          label.style.padding = '2px 4px';
          label.style.whiteSpace = 'nowrap';
          label.style.zIndex = 20 + idx;
          label.style.pointerEvents = 'auto';
          overlay.appendChild(label);

          // Close button
          const closeBtn = document.createElement('div');
          closeBtn.className = 'span-close';
          closeBtn.textContent = '√ó';
          closeBtn.style.position = 'absolute';
          closeBtn.style.top = '-20px';
          closeBtn.style.right = '0';
          closeBtn.style.background = 'white';
          closeBtn.style.border = '1px solid rgb' + span.border_rgb;
          closeBtn.style.width = '16px';
          closeBtn.style.height = '16px';
          closeBtn.style.textAlign = 'center';
          closeBtn.style.lineHeight = '14px';
          closeBtn.style.cursor = 'pointer';
          closeBtn.style.zIndex = 21 + idx;
          closeBtn.style.pointerEvents = 'auto';
          closeBtn.onclick = function(e) {
            e.stopPropagation();
            // Send delete request
            var instance_id = document.getElementById('instance_id').value;
            var post_req = {
              type: 'span',
              schema: span.schema,
              state: [{
                name: span.label,
                start: span.start,
                end: span.end,
                title: span.title,
                value: null
              }],
              instance_id: instance_id
            };
            fetch('/updateinstance', {
              method: 'POST',
              body: JSON.stringify(post_req),
              credentials: 'same-origin',
              headers: {
                'Content-type': 'application/json; charset=UTF-8',
              },
            }).then(response => {
              if (response.ok) {
                location.reload();
              } else {
                alert('Failed to delete span annotation');
              }
            });
          };
          overlay.appendChild(closeBtn);

          overlays.appendChild(overlay);
          console.log(`‚úÖ Added overlay for span ${idx}, rect ${rectIdx}`);
        });
      } catch (err) {
        console.error('‚ùå Error rendering span overlay:', err);
      }
    });

    console.log('üîç renderSpanOverlays completed');
  }
  window.addEventListener('resize', renderSpanOverlays);
  document.addEventListener('DOMContentLoaded', renderSpanOverlays);
  window.renderSpanOverlays = renderSpanOverlays;
})();
</script>
</body>
</html>