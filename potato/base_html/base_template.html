<!DOCTYPE html>
<html lang="en">

  <!--- HEADER GOES BELOW HERE--->

  {{ HEADER }}

  <!--- HEADER GOES ABOVE HERE--->

  {{ custom_js | safe }}

  <body>



    <input type="hidden" name="username" id="username" value="{{username}}">
    <input type="hidden" name="instance_id" id="instance_id" value="{{instance_id}}">
    <input type="hidden" name="alert_time_each_instance" id="alert_time_each_instance" value="{{alert_time_each_instance}}">
    <p id="timecounter" hidden>Time spent:</p>

    <div id="mySidepanel" class="sidepanel">
      <a href="javascript:void(0)" class="closebtn" target_id="mySidepanel" onclick="closeNav(this.getAttribute('target_id'))">&times;</a>
      {{keybindings}}
    </div>

    <div id="Statpanel" class="sidepanel">
      <a href="javascript:void(0)" class="closebtn" target_id="Statpanel" onclick="closeNav(this.getAttribute('target_id'))">&times;</a>
      [[statistics_nav]]
    </div>

    <script>
      document.addEventListener('keyup', function (event) {
          var active_id = document.activeElement.id;
          var active_type = document.activeElement.getAttribute('type');
          if (active_id == 'go_to' | active_type == 'text') return;

          //first check whether this keyboard input is a shortcut for checkboxes
          var checkboxes = document.querySelectorAll('input[type=checkbox]');
          var radios = document.querySelectorAll('input[type=radio]');
          var x = event.key.toLowerCase();

          for (var i = 0; i < checkboxes.length; i++) {
              //alert(checkboxes[i].value)
              if(x === checkboxes[i].value){
                  checkboxes[i].checked = !checkboxes[i].checked;
                  if (checkboxes[i].onclick != null) checkboxes[i].onclick.apply(checkboxes[i]);
                  return;
              };
          }
          for (var i = 0; i < radios.length; i++) {
              //alert(checkboxes[i].value)
              if(x === radios[i].value){
                  radios[i].checked = !radios[i].checked;
                  if (radios[i].onclick != null) radios[i].onclick.apply(radios[i]);
                  return;
              };
          }

          // Each time we process a user's key presses, track who is doing
          // it by grabbing the hidden firstname and lastname fields
          get_new_instance(event);
      });

      function getFieldSetState(element) {
        // console.dir('saw annotation' + element.value);
        // console.dir(element.parentElement);
        //var fieldSet = element.parentElement;

        // Find the closeset ancestor fieldset element from this input
        var fieldSet = element.closest('fieldset');

        // Get all the inputs in this field set (what are the annotation options)
        var inputs = fieldSet.querySelectorAll('input');

        // Get state of all the in this group
        var state = Array.from(inputs).map(input => {
          return {
            name: input.getAttribute('label_name'),
            value: input.checked,
            // checked: input.value // unused??
          }
        });
        return state
      }

      function registerAnnotation(element) {

        // If the element is a radio button, we need to uncheck all the other which
        // requires sending the state of all the other buttons in the group
        sc = element.getAttribute("selection_constraint")
        if (sc && sc == "single") {
            state = getFieldSetState(element);
        }
        else if (element.getAttribute('type') == 'range') {
            state = [{
              name: element.getAttribute('label_name'),
              value: element.value,
            }]
        }
        // This is a checkbox so we can just send the state of this checkbox
        else {
            state = [{
              name: element.getAttribute('label_name'),
              value: element.checked,
              // checked: element.value // unused??
            }]
        }

        // Get which annotation group this change belongs to
        var schema = element.getAttribute('schema');

        // Get the instance id
        var instance_id = document.getElementById('instance_id').value;

        // Package this all up in a post request to the server's updateinstance endpoint
        var post_req = {
          type: "label",
          schema: schema,
          state: state,
          instance_id: instance_id
        }

        // Send the post request
        fetch("/updateinstance", {
            method: "POST",
            body: JSON.stringify(post_req),
            credentials: "same-origin",
            headers: {
                "Content-type": "application/json; charset=UTF-8"
            }
            });
      }

      function registerTextAnnotation(element) {

        // Get which annotation group this change belongs to
        var schema = element.getAttribute('schema');

        // Get the instance id
        var instance_id = document.getElementById('instance_id').value;

        state = [{
              name: element.getAttribute('label_name'),
              value: element.value,
            }]

        // Package this all up in a post request to the server's updateinstance endpoint
        var post_req = {
            type: "label",
            schema: schema,
            state: state,
            instance_id: instance_id
        }

        // Send the post request
        fetch("/updateinstance", {
            method: "POST",
            body: JSON.stringify(post_req),
            credentials: "same-origin",
            headers: {
                "Content-type": "application/json; charset=UTF-8"
            }
            });

      }

      function getSelectedText() {
          var text = "";
          if (typeof window.getSelection != "undefined") {
              text = window.getSelection().toString();
          } else if (typeof document.selection != "undefined" && document.selection.type == "Text") {
              text = document.selection.createRange().text;
          }
          return text;
      }

      function deleteSpanAnnotation(spanElem, schema, labelName, title, start, end) {
            // Get the instance id
            var instance_id = document.getElementById('instance_id').value;

            // Get the text of the span
            var spanText = spanElem.innerText;

            // Package this all up in a post request to the server's updateinstance endpoint
            var post_req = {
                type: "span",
                schema: schema,
                state: [{
                    name: labelName,
                    start: start,
                    end: end,
                    title: title,
                    value: null
                }],
                instance_id: instance_id
            }

            // Send the post request
            fetch("/updateinstance", {
                method: "POST",
                body: JSON.stringify(post_req),
                credentials: "same-origin",
                headers: {
                    "Content-type": "application/json; charset=UTF-8"
                }
            });

            // Remove the outer most div tag that has the span's annotation title (the small text above)
            $( spanElem ).find("div").first().remove()
            // Remove the close tag
            $( spanElem ).find("div").last().remove()
            // Remove the span highlight by unwrapping the inner text
            $( spanElem.firstChild ).unwrap();
      }


      function getEarlierChildren(n, skipMe){
            var r = [];
            for ( ; n; n = n.nextSibling )
                if ( n.nodeType == 1 && n != skipMe)
                    r.push( n );
                else if ( n == skipMe )
                    break;
            return r;
        };

        function getEarlierSiblings(n) {
            return getEarlierChildren(n.parentNode.firstChild, n);
        }

        function getTextOfSpans(elems) {
            text = ""
            for (i = 0; i < elems.length; i++) {
                //console.log(elems[i].textContent)

                e = elems[i].cloneNode(true);
                console.log('e', e)
                // Delete all the nested <div> elements with jquery to get the plain text
                $(e).find('div').remove();
                console.log('sib text', e.textContent)
                text += " " + e.textContent

            }

            return text.trim();
        }

      function getSelectionIndices() {
            // Get the user selection
            var selection = window.getSelection();

            if (selection.rangeCount === 0) {
                return { start: -1, end: -1 }; // No selection
            }

            // Get the range object representing the selected portion
            var range = selection.getRangeAt(0);

            // Get the left most element in the selection
            var leftMost = range.startContainer;
            var leftSibs = getEarlierSiblings(leftMost);
            console.log('leftSibs', leftSibs);
            // Get the text of the left elements
            var leftText = getTextOfSpans(leftSibs);

            // Find the parent div element with name "instance_text" using jquery
            var parentDiv = $(range.commonAncestorContainer).closest('div[name="instance_text"]')[0];
            //console.log('parentDiv', parentDiv)

            if (!parentDiv) {
                return { start: -2, end: -2 }; // Not within a <div class="context_text">
            }

            //console.log('parentDiv')
            //console.dir(parentDiv.innerHTML)

            // Make a copy of the parent div to manipulate
            parentDiv = parentDiv.cloneNode(true);

            // Create a temporary Range to find the offset relative to the parent div
            console.log('before delete', range.startContainer, range.startOffset, range.endOffset)
            var tempRange = document.createRange();
            tempRange.setStart(parentDiv, 0);
            tempRange.setEnd(range.startContainer, range.startOffset);

            // Delete all the nested <div> elements with jquery to get the plain text
            $(parentDiv).find('div').remove();

            console.log('after delete')
            console.dir(parentDiv.innerHTML)
            console.log('text')
            console.dir(parentDiv.textContent)

            console.log('after delete', range.startContainer, range.startOffset, range.endOffset)


            // Get the starting offset of the selection within the parent div
            var div = document.createElement("div");
            div.appendChild(tempRange.cloneContents());

            var s = range.startContainer.textContent.toString();
            //console.log(`text: "${text}"`);
            var whitespaceOffset = s.length - s.trimStart().length;


            var startOffset = range.startOffset - whitespaceOffset;

            if (leftText.length > 0) {
                // Add 1 for space between the left text and the selected text
                startOffset += leftText.length + 1;
            }

            // Get the length of the selected text
            var selectedTextLength = range.toString().length;

            // Calculate the ending offset of the selection within the parent div
            var endOffset = startOffset + selectedTextLength;

            return { start: startOffset, end: endOffset };
        }



      function surroundSelection(schema, labelName, title, selectionColor)  {
          //var span = document.createElement("span");
          //span.style.fontWeight = "bold";
          //span.style.color = "green";

        // Check that this wasn't a spurious click or the click for the delete button which
        // also seems to trigger this selection event
        if (window.getSelection().rangeCount == 0) {
            return;
        }
        var range = window.getSelection().getRangeAt(0)

        // console.dir(window.getSelection())

        // console.log(range.startOffset, range.endOffset)
        if (range.startOffset == range.endOffset) {
            return;
        }


        // Get the instance id
        var instance_id = document.getElementById('instance_id').value;

          if (window.getSelection) {
              var sel = window.getSelection();

              // console.dir(sel);

              // Check that we're labeling something in the instance text that
              // we want to annotate
              if (!sel.anchorNode.parentElement) {
                return;
              }

              // TODO: check that we're not nesting a span of the same time here

              // Otherwise, we're going to be adding a new span annotation, if
              // the user has selected some non-empty part of the text
              if (sel.rangeCount && sel.toString().trim().length > 0) {



                  // Get the selection text as a string
                  var selText = window.getSelection().toString().trim();
                  console.log('selText1', selText);

                  // Get the start and end offsets of the selection
                  var range = sel.getRangeAt(0);
                  var start = range.startOffset;
                  var end = range.endOffset;
                  // Get the generic text between the start and end offsets
                  var text = range.startContainer.textContent.substring(start, end);
                  var s = range.startContainer.textContent.toString();
                  //console.log(`text: "${text}"`);
                  var whitespaceOffset = s.length - s.trimStart().length;
                  //console.log('whitespaceOffset', whitespaceOffset);

                  /*
                  console.log(`full range text "${range.startContainer.textContent}`);
                  console.log('start', start);
                  console.log('end', end);
                  console.log('start', start - whitespaceOffset);
                  console.log('end', end - whitespaceOffset);
                  console.log(`ranged substring "${text}"`);
                    */
                  // Get the raw text of the selection without any HTML
                  var sel = window.getSelection();
                  var range = sel.getRangeAt(0);
                  var div = document.createElement("div");
                  div.appendChild(range.cloneContents());
                  var selText = div.innerHTML;
                  //console.log(`selText2: "${selText}"`);



                  tsc = selectionColor.replace(")", ", 0.25)")

                  var span = document.createElement("span");
                  span.className = "span_container";
                  span.setAttribute("selection_label", labelName);
                  span.setAttribute("style", "background-color:rgb" + tsc + ";");

                  var label = document.createElement("div");
                  label.className = "span_label";
                  label.textContent = title;
                  label.setAttribute("style", "background-color:white;"
                                    + "border:2px solid rgb" + selectionColor + ";");


                  var delLabel = document.createElement("div");
                  delLabel.className = "span_close";
                  delLabel.textContent = "Ã—";
                  delLabel.setAttribute("style", "background-color:white;");
                  //                  + "border:2px solid rgb" + selectionColor + ";");
                  delLabel.onclick= function() {
                    deleteSpanAnnotation(span, schema, labelName, title, range.startOffset, range.endOffset);
                  };

                  // Get the offsets
                  startEnd = getSelectionIndices();
                  console.log('startEnd', startEnd);
                  state = [{
                      name: labelName,
                      start: startEnd['start'],
                      end: startEnd['end'],
                      title: title,
                      value: sel.toString()
                  }]

                  // console.log('adding new annotation', range.startOffset, range.endOffset, sel.toString())

                  // Package this all up in a post request to the server's updateinstance endpoint
                 var post_req = {
                    type: "span",
                    schema: schema,
                    state: state,
                    instance_id: instance_id
                 }

                 // Send the post request
                 fetch("/updateinstance", {
                    method: "POST",
                    body: JSON.stringify(post_req),
                    credentials: "same-origin",
                    headers: {
                        "Content-type": "application/json; charset=UTF-8"
                    }
                 });

                 var range = sel.getRangeAt(0).cloneRange();
                 range.surroundContents(span);
                 sel.removeAllRanges();
                 sel.addRange(range);
                 span.appendChild(label);
                 span.appendChild(delLabel);

                 // Clear the current selection
                 sel.empty();
              }
          }
      }

      function changeSpanLabel(checkbox, schema, spanLabel, spanTitle, spanColor) {
          // Listen for when the user has highlighted some text (only when the label is checked)
          document.onmouseup = function(e) {

            var senderElement = e.target;
            // Avoid the case where the user clicks the delete button
              if (senderElement.getAttribute("class") == "span_close") {
                  e.stopPropagation()
                  return true;
              }
              if (checkbox.checked){
                  surroundSelection(schema, spanLabel, spanTitle, spanColor);
              }
          }
      }

      // Listen for when the user has highlighted some text
      // document.onmouseup = function() { surroundSelection("Undefined"); }

    </script>
    <script>
      function barValue(range,sibling) {
          // function used to obtain value for range input
          sibling.value = range.value;
          //var x = document.getElementsByClassName(range.className);
          //var i;
          //for (i=0: i < x.length; i++) {
          //    if(x[i].value != range.value) x[i]
          //}
      }
    </script>

    <script>
      function onlyOne(checkbox) {
	  // this function is used for the single-choice setting
	  //alert(checkbox.className)
	  var x = document.getElementsByClassName(checkbox.className);
	  var i;
	  for (i = 0; i < x.length; i++) {
	      if(x[i].value != checkbox.value) x[i].checked = false;
	  }
      }
    </script>


    <script>
      function whetherNone(checkbox) {
	  // this function is used to uncheck all the other labels when "None" is checked
	  //alert(checkbox.className)
	  var x = document.getElementsByClassName(checkbox.className);
	  var i;
	  for (i = 0; i < x.length; i++) {
              if(checkbox.value == "None" && x[i].value != "None") x[i].checked = false;
              if(checkbox.value != "None" && x[i].value == "None") x[i].checked = false;
          }

      }
    </script>

    <script>
      function click_to_next() {
          // Gacky code to simulate the submit button as a keyboard event
          // and not have two separate paths to handle keyboard and mouse
          // events
          var e = $.Event('keyup');
          e.key = "ArrowRight";

          get_new_instance(e);
      }

      function click_to_prev() {
          // Gacky code to simulate the submit button as a keyboard event
          // and not have two separate paths to handle keyboard and mouse
          // events
          var e = $.Event('keyup');
          e.key = "ArrowLeft";

          get_new_instance(e);
      }

    </script>

    {{annotation}}

    <script>
        /*
      window.onunload = check_close;
      function check_close() {
          // console.error("session closed");
          var post_req = {
              is_close: "closed"
          }
          post(post_req);
      }
          */
    </script>

    <script>
      // Set the date we're counting down to
      var countDownDate = new Date().getTime();

      // Update the count down every 1 second
      var x = setInterval(function() {

          // Get today's date and time
          var now = new Date().getTime();

          // Find the distance between now and the count down date
          var distance = now - countDownDate;

          // Time calculations for days, hours, minutes and seconds
          var days = Math.floor(distance / (1000 * 60 * 60 * 24));
          var hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
          var minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
          var seconds = Math.floor((distance % (1000 * 60)) / 1000);
          var total_seconds = Math.floor(distance / 1000);

          // Output the result in an element with id="timecounter"

          //document.getElementById("timecounter").innerHTML = "Time spent: " + days + "d " + hours + "h "
          //    + minutes + "m " + seconds + "s ";

          // TODO: add configurations for alert message and maximum time spent on each instance
          // If the count down is over, write some text

          var alert_time_each_instance = document.getElementById("alert_time_each_instance").value;
          if (total_seconds % alert_time_each_instance == 0) {
              //clearInterval(x);
              //document.getElementById("timecounter").innerHTML = "EXPIRED";
              alert("You have spent " + total_seconds + " seconds on this instance")
          }

      }, 1000);
    </script>

    <script>
      // We submit a new post to the same (user/annotate) endpoint
      function post(params) {

        // Package this all up in a post request to the server's updateinstance endpoint
        var post_req = {
            instance_id: instance_id
        }
        for (var key in params) {
              if (params.hasOwnProperty(key)) {
                post_req[key] = params[key];
              }
          }

        // Send the post request and re-render the page with the new instance
        //
        // TODO: fix this the server-client protocol so we're just sending over
        // the new instance data and not the entire page
        fetch("/", {
            method: "POST",
            body: JSON.stringify(post_req),
            credentials: "same-origin",
            headers: {
                "Content-type": "application/json; charset=UTF-8"
            }
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.text(); // Assuming the response is text/html
            })
            .then(html => {
                // 2. Update the page content
                document.body.innerHTML = html;
                // Add all the listeners back to the new page
                watch_text_boxes();
            })
            .catch(error => {
                console.error('Error:', error);
                // Handle errors appropriately, e.g., display an error message
            });

          /*


          // The rest of this code assumes you are not using a library.
          // It can be made less wordy if you use one.
          var form = document.createElement("form");
          form.setAttribute("method", "post");
          form.setAttribute("action", "/");

          var hiddenField = document.createElement("input");
          hiddenField.setAttribute("type", "hidden");
          hiddenField.setAttribute("name", "email");
          hiddenField.setAttribute("value", document.getElementById('username').value);
          form.appendChild(hiddenField);

          for (var key in params) {
              if (params.hasOwnProperty(key)) {
                  var hiddenField = document.createElement("input");
                  hiddenField.setAttribute("type", "hidden");
                  hiddenField.setAttribute("name", key);
                  hiddenField.setAttribute("value", params[key]);

                  form.appendChild(hiddenField);
              }
          }

          // Stuff all the current annotations into attributes for processing on the server side
          $('form input, form select, form textarea').each(
              function(index){
                  var input = $(this);

                  if (input.attr('type') == 'checkbox' || input.attr('type') == 'radio') {
                      if (input.is(":checked")) {
                          // Stuff all the input fields into something for the post
                          var hiddenField = document.createElement("input");
                          hiddenField.setAttribute("type", "hidden");
                          hiddenField.setAttribute("name", input.attr('name'));
                          hiddenField.setAttribute("value", input.attr('value'));
                          form.appendChild(hiddenField);
                      }
                  }
                  else if (input.attr('type') == 'text' || input.attr('type') == 'number') {
                      var hiddenField = document.createElement("input");
                      hiddenField.setAttribute("type", "hidden");
                      hiddenField.setAttribute("name", input.attr('name'));
                      hiddenField.setAttribute("value", input[0].value);
                      form.appendChild(hiddenField);
                  }
                  else if (input.attr('type') == 'range') {
                      var hiddenField = document.createElement("input");
                      hiddenField.setAttribute("type", "hidden");
                      hiddenField.setAttribute("name", input.attr('name'));
                      hiddenField.setAttribute("value", input[0].value);
                      form.appendChild(hiddenField);
                  }
                  else if (input.attr('type') == 'select-one') {
                      //alert(input[0].value)
                      var hiddenField = document.createElement("input");
                      hiddenField.setAttribute("type", "hidden");
                      hiddenField.setAttribute("name", input.attr('name'));
                      hiddenField.setAttribute("value", input[0].value);
                      form.appendChild(hiddenField);
                  }
                  else {
                      console.log("unknown form type: \"" + input.attr('type') + "\"")
                  }
              }
          );
          */

          /*
          // Get all the highlighted text for this instance and marshall that
          // into some kind of representation for the server side
          $(".span_container").first().each(
              function(index) {

                  // we save the outerHTML to accomadate user-defined HTML inputs,
                  // otherwise we just save the plain text
                  if ($(this).parent().parent().attr("name") == "instance_text"){
                      var annotated_spans = $(this).parent().prop('outerHTML');
                  } else {
                      var annotated_spans = $(this).parent().prop('innerHTML');
                  }

                  // Due to the DJ's inability to write decent Javascript, we're
                  // fully punting on the idea of doing label preprocessing here
                  // and instead shuttling the entire HTML of the instance to
                  // the server for python-based processing. The main issue is
                  // figuring out the precise text offsets of the annotated
                  // spans while dealing with nested DOM elements.
                  var hiddenField = document.createElement("input");
                  hiddenField.setAttribute("type", "hidden");
                  hiddenField.setAttribute("name", "span-annotation");
                  hiddenField.setAttribute("value", annotated_spans);
                  form.appendChild(hiddenField);
                  //console.log(annotated_spans)
              }
          );
          */

          //document.body.appendChild(form);
          //form.submit();
      }

      /**
       * Validate if the user has completed each row for multi-rate schema
       */
      function validateForm() {
        var rows = document.querySelectorAll("tr[schema='multirate']");
        for (var i = 0; i < rows.length; i++) {
          var inputs = rows[i].querySelectorAll("input[type='radio'][validation='required']");
          if (inputs.length > 0) {
              var checked = Array.from(inputs).some(input => input.checked);
          } else {
              var checked = true;
          }

          if (!checked) {
            alert("Please complete all the require fields");
            return false;
          }
        }
        return true;
      }


       /**
       * Validate if the input answers meet certain rules
       * along with any relevant key presses to request a new instance to
       * annotate.
       */
      function validate_answers() {

          // Test whether all the required labels are checked
          var inputs =  document.querySelectorAll('input[validation=required_label]');
          for (var i = 0; i < inputs.length; ++i) {
            if (inputs[i].getAttribute('validation') == 'required_label' && inputs[i].checked == false){
                // Get the text of the legend element that contains the question
                var legend = inputs[i].closest('fieldset').querySelector('legend');
                var question = legend.textContent;

                // Get the text of the answer
                var neededAnswer = inputs[i].getAttribute('label_name');

                // Generate an alert that shows the question text and the required label
                // so the user knows what they missed
                alert("The question \"" + question + "\" requires the label \"" + neededAnswer
                            + "\" to be selected to proceed");
                return false;
            }
          }


          // identify all the fieldsets and check if all the required forms are filled
          var fields = document.getElementsByTagName('fieldset');
          for (var i = 0; i < fields.length; ++i) {
                var inputs = fields[i].querySelectorAll('input[validation=required], select[validation=required], textarea[validation=required]');

                // continue if all there's no required inputs in the current field set
                if (inputs.length == 0){
                    continue;
                }
                //var required = true;
                // check if the current form requires inputs
                //if (inputs[0].getAttribute('validation') == 'required'){
                //    required= true;
                //}


                checked_flag = false;
                for (var j = 0; j < inputs.length; ++j) {
                    // if a right_label is not selected, display an error msg and return false
                    //if (inputs[j].getAttribute('validation') == 'right_label' && inputs[j].checked == false) {
                        //alert(inputs[j].name + " must be selected to proceed");
                    //    return false;
                    //}
                    // if the input is for a span annotation schema, check if the at least some span is annotated or if the
                    // bad_text label is selected
                    if (inputs[j].getAttribute("for_span") == "True"){
                        //alert($(".span_container").length);
                        if ($(".span_container").length > 0) {
                            checked_flag = true;
                            break;
                        } else if (inputs[j].name.slice(-8) == "bad_text" && inputs[j].checked == true){
                            checked_flag = true;
                            break;
                        }
                    }


                    // if any of the labels is checked, set checked_flag as true;
                    if (inputs[j].getAttribute("for_span") != "True" && inputs[j].checked == true) {

                        checked_flag = true;
                        break;
                    }

                    // if the input_type is number, text, select or textarea, check if it's empty
                    // todo: the current way might not work well if there are mixed textinput and radio buttons under a sample fieldset
                    if (inputs[j].type == "text" || inputs[j].tagName == "TEXTAREA" || inputs[j].type == "number" || inputs[j].type == "select-one") {
                        if (inputs[j].value.length == 0){
                            alert(inputs[j].name + " must be completed to proceed");
                            return false;
                        }
                        else{
                            checked_flag = true;
                        }
                    }
                }

                // Get the text of the legend element that contains the question
                //
                // TODO: check that this works with questions for the text input fields
                var legend = inputs[i].closest('fieldset').querySelector('legend');
                var question = legend.textContent;

                // if this form requires inputs, but nothing is checked, display an error msg and return false
                if (checked_flag == false){
                    alert("You must answer the following item to proceed: " + question  );
                    return false;
                }
                //alert(instance_obj.id)
          }
          return true;
      }


      /**
       * Sends the current state of the instance's annotation to the server,
       * along with any relevant key presses to request a new instance to
       * annotate.
       */
      function get_new_instance(event) {
          var x = event.key;
          var action = ""
          var ism = ""

          //console.log(x)
          //console.log(firstname)
          //console.log(lastname)
          if (x == "ArrowLeft") { // Spacebar
              action = "prev_instance";
          }
          else if (x == "ArrowRight") {
            //console.log("validateForm", validateForm())
            //console.log("validate_answers", validate_answers())
              if (validateForm() == true && validate_answers() == true) {
                  action = "next_instance";
              }
              else{
                  return;
              }
          }
          else {
              // console.log("Unknown key press", event)
              return
          }

          var instance_id = document.getElementById('instance_id').value
          var time_string = document.getElementById("timecounter").innerHTML //get time spent on this instance
          //time_string = '-1'
          var post_req = {
              label: ism,
              "action": action,
              instance_id: instance_id,
              behavior_time_string: time_string
          }

          console.log('post_req: ', post_req)
          // Sends the post message to the server which will let us update the
          // currently displayed content
          post(post_req)
      }

    </script>

    <script>
      $(document).ready(function(){
          $('[data-toggle="tooltip"]').tooltip();
      });
    </script>

    {{var_elems | safe}}

    <nav class="navbar navbar-expand-md shadow-sm mb-4" style="background-color: var(--background);">
      <div class="container-fluid">
        <a href="#" class="navbar-brand fw-bold" style="color: var(--primary);">{{annotation_task_name}}</a>
        <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbarCollapse">
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarCollapse">
          <div class="navbar-nav">
            <a href="#" class="nav-item nav-link" style="color: var(--primary);">Home</a>
            {{annotation_codebook}}
            <a role="button" href="#" class="nav-item nav-link openbtn" target_id="Statpanel" width="475px" onclick="openNav(this.getAttribute('target_id'),this.getAttribute('width'))">Statistics</a>
            <a role="button" href="#" class="nav-item nav-link openbtn" target_id="mySidepanel" onclick="openNav(this.getAttribute('target_id'))">Help</a>
          </div>
          <div class="ms-auto d-flex align-items-center">
            <div class="me-3" style="color: var(--muted-foreground);">
              Finished <span class="fw-medium">{{finished}}/{{total_count}}</span>
            </div>
            <div class="me-3" style="color: var(--muted-foreground);">
              Current ID <span class="fw-medium">{{instance_index}}</span>
            </div>
            <div class="me-3">
              <form action="/go_to" method="post" class="d-flex">
                <input type="hidden" name="firstname" id="a" value="{{firstname}}">
                <input type="hidden" name="lastname" id="b" value="{{lastname}}">
                <input type="hidden" name="email" id="c" value="{{username}}">
                <input type="hidden" name="src" id="src" value="go_to">
                <input type="number" name="go_to" id="go_to" class="form-control form-control-sm me-2"
                  style="width: 70px; border-color: var(--border); border-radius: var(--radius);"
                  value="" onfocusin="user_input()" onfocusout="user_input_leave()" max={{total_count}} min=0 required>
                <button type="submit" class="shadcn-button shadcn-button-primary" style="height: 31px;">Go</button>
              </form>
            </div>
            <div style="color: var(--muted-foreground);">
              Logged in as <span class="fw-medium">{{username}}</span>
            </div>
          </div>
        </div>
      </div>
    </nav>
    <div class="container-fluid">

      <div id="task_layout">

         <!--- LAYOUT GOES BELOW HERE --->

         {{ TASK_LAYOUT }}

        <!--- LAYOUT GOES ABOVE  --->

      </div>

      <div class="my-4">
        <div class="text-center">
          <a class="shadcn-button shadcn-button-outline me-2" href="#" role="button" onclick="click_to_prev()">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-arrow-left me-1" viewBox="0 0 16 16">
              <path fill-rule="evenodd" d="M15 8a.5.5 0 0 0-.5-.5H2.707l3.147-3.146a.5.5 0 1 0-.708-.708l-4 4a.5.5 0 0 0 0 .708l4 4a.5.5 0 0 0 .708-.708L2.707 8.5H14.5A.5.5 0 0 0 15 8z"/>
            </svg>
            Previous
          </a>
          <a class="shadcn-button shadcn-button-primary" href="#" role="button" onclick="click_to_next()">
            Next
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-arrow-right ms-1" viewBox="0 0 16 16">
              <path fill-rule="evenodd" d="M1 8a.5.5 0 0 1 .5-.5h11.793l-3.147-3.146a.5.5 0 0 1 .708-.708l4 4a.5.5 0 0 1 0 .708l-4 4a.5.5 0 0 1-.708-.708L13.293 8.5H1.5A.5.5 0 0 1 1 8z"/>
            </svg>
          </a>
        </div>
      </div>

      <hr style="color: var(--border);">
      <footer class="py-3">
        <div class="row">
          <div class="col-md-6">
            <p style="color: var(--muted-foreground);">Copyright &copy; 2025 <a href="https://blablablab.si.umich.edu/" style="color: var(--primary); text-decoration: none;">Blablablab</a></p>
          </div>
          <div class="col-md-12 text-md-end">
            <a href="https://github.com/davidjurgens/potato" style="color: var(--primary); text-decoration: none;">Fork on GitHub</a>
            <span class="mx-2" style="color: var(--muted-foreground);">|</span>
            <a href="https://github.com/davidjurgens/potato#cite-us" style="color: var(--primary); text-decoration: none;">Cite Us</a>
          </div>
        </div>
      </footer>
    </div>

    <script>
      /* Set the width of the sidebar to 250px (show it) */
      function openNav(target_id, width = "350px") {
          document.getElementById(target_id).style.width = width;
      }

      /* Set the width of the sidebar to 0 (hide it) */
      function closeNav(target_id) {
          document.getElementById(target_id).style.width = "0";
      }

      function closeNav2(target_id) {
          // document.getElementById(target_id).style.height = "20px";
          console.error(document.getElementById(target_id).style.display);
          if (document.getElementById(target_id).style.display == "block"
              || document.getElementById(target_id).style.display == "") {

              document.getElementById(target_id).style.display = "none";
              localStorage.setItem('show_instructions', 'false');
          }
          else{
              document.getElementById(target_id).style.display = "block";
              localStorage.setItem('show_instructions', 'true');
          }
      }

      /* Keep the instructions hidden/shown across instance transitions based on
         what the user had selected */
      window.addEventListener("load", function() {
          var show = localStorage.getItem('show_instructions');
          if (document.getElementById('instructions')) {
              if (show === 'true') {
                  document.getElementById('instructions').style.display = "block";
              }
              else {
                  document.getElementById('instructions').style.display = "none";
              }
          }
      });

    function watch_text_boxes() {
        let timer;
        const waitTime = 1000;

        var text_boxes = document.querySelectorAll('input[type=text]');
        for (var i = 0; i < text_boxes.length; i++) {
            //console.log('adding event listener to text box');
            //console.log(text_boxes[i]);
            text_boxes[i].addEventListener('input', function (event) {
                console.log('text box input event')
                clearTimeout(timer);
                timer = setTimeout(() => {
                    registerTextAnnotation(event.target);
                }, waitTime);
            });
        }

        var text_areas = document.querySelectorAll('textarea');
        //console.log('num text_areas: ' + text_areas.length);
        for (var i = 0; i < text_areas.length; i++) {
            //console.log('adding event listener to text area');
            //console.dir(text_areas[i]);
            text_areas[i].addEventListener('input', function (event) {
                //console.log('text area input event')
                clearTimeout(timer);
                timer = setTimeout(() => {
                    registerTextAnnotation(event.target);
                }, waitTime);
            });
        }
    }
    watch_text_boxes();
    </script>
  </body>
</html>
